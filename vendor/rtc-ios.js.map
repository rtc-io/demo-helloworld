{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "index.js",
    "node_modules/rtc-proxy/index.js",
    "node_modules/rtc-proxy/mediastream.js",
    "node_modules/rtc-proxy/node_modules/cog/extend.js",
    "node_modules/rtc-proxy/node_modules/eventemitter3/index.js",
    "node_modules/rtc-proxy/peerconnection.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/* jshint node: true */\n'use strict';\n\nvar ProxyMediaStream = require('rtc-proxy/mediastream');\nvar ProxyPeerConnection = require('rtc-proxy/peerconnection');\nvar reNICTAUserAgent = /\\(iOS\\;.*Mobile\\/NICTA/;\nvar deviceReady = false;\nvar initialized = false;\n\n/**\n  # rtc-plugin-nicta-ios\n\n  This is an experimental plugin for bridging the functionality provided\n  an in-progress NICTA iOS webkit plugin.  While this plugin integration\n  layer is provided opensource the iOS plugin is a commercial project\n  currently under development.\n\n  ## Getting More Information\n\n  If you are after more information regarding the plugin feel free to\n  reach out to either of the following people, and we will do our best\n  to answer your questions:\n\n  - Damon Oehlman <damon.oehlman@nicta.com.au>\n  - Silvia Pfeiffer <silvia.pfeiffer@nicta.com.au>\n\n**/\n\n/**\n  ### supported(platform) => Boolean\n\n  The supported function returns true if the platform (as detected using\n  `rtc-core/detect`) is compatible with the plugin. By doing this prelimenary\n  detection you can specify a number of plugins to be loaded but only\n  the first the is supported on the current platform will be used.\n\n**/\nexports.supported = function(platform) {\n  return typeof navigator != 'undefined' && reNICTAUserAgent.test(navigator.userAgent);\n};\n\n/**\n  ### init(callback)\n\n  The `init` function is reponsible for ensuring that the current HTML\n  document is prepared correctly.\n\n**/\nvar init = exports.init = function(opts, callback) {\n  function ready(evt) {\n    var oldLogger;\n\n    if (initialized) {\n      return callback();\n    }\n\n    document.removeEventListener('deviceready', ready);\n\n    // override the console.log implementation to report back to the iOS console\n    oldLogger = window.console.log;\n    window.console.log = function(msg) {\n      var nativeMessage = [].slice.call(arguments).join(' ');\n\n      try {\n        NativeLog(nativeMessage);\n      }\n      catch (e) {\n        alert(nativeMessage);\n      }\n\n      oldLogger.apply(window.console, arguments);\n    };\n\n    if (typeof getUserMedia == 'function') {\n      navigator.getUserMedia = function(constraints, successCb, failureCb) {\n        getUserMedia(constraints, function(stream) {\n          successCb(new ProxyMediaStream(stream));\n        }, failureCb);\n      };\n    }\n\n    initialized = true;\n    console.log('iOS plugin initialized, getUserMedia available = ' + (!!navigator.getUserMedia));\n\n    callback();\n  }\n\n  // if the device is ready, then initialise immediately\n  if (deviceReady) {\n    // initialise after a 10ms timeout\n    return setTimeout(ready, 10);\n  }\n\n  // wait for the device ready call\n  document.addEventListener('deviceready', ready);\n};\n\nexports.attach = function(stream, opts) {\n  var canvas = prepareElement(opts, (opts || {}).el);\n  var context = canvas.getContext('2d');\n  var lastWidth = 0;\n  var lastHeight = 0;\n\n  // if we are a proxyied stream, get the original stream\n  if (stream && stream.__orig) {\n    stream = stream.__orig;\n  }\n\n  iOSRTC_onDrawRegi(stream, function(imgData, width, height) {\n    var resized = false;\n\n    console.log('rendering stream frame');\n\n    try {\n      var img = new Image();\n      resized = width !== lastWidth || height !== lastHeight;\n\n      img.onload = function() {\n        if (resized) {\n          context.canvas.width = width;\n          context.canvas.height = height;\n        }\n        context.drawImage(img, 0, 0, width, height);\n      };\n      img.src = imgData;\n    }\n    catch (e) {\n      console.log('encountered error while drawing video');\n      console.log('error: ' + e.message);\n    }\n\n    // update the last width and height\n    lastWidth = width;\n    lastHeight = height;\n  });\n\n  return canvas;\n};\n\n/**\n  ### attachStream(stream, bindings)\n\n**/\nexports.attachStream = function(stream, bindings) {\n  var contexts = [];\n  var lastWidth = 0;\n  var lastHeight = 0;\n\n  // get the contexts for each of the bindings\n  contexts = bindings.map(function(binding) {\n    return binding.el.getContext('2d');\n  });\n\n  // if we are a proxyied stream, get the original stream\n  if (stream && stream.__orig) {\n    stream = stream.__orig;\n  }\n\n  iOSRTC_onDrawRegi(stream, function(imgData, width, height) {\n    var resized = false;\n    try {\n      var img = new Image();\n      resized = width !== lastWidth || height !== lastHeight;\n\n      img.onload = function() {\n        contexts.forEach(function(context) {\n          if (resized) {\n            context.canvas.width = width;\n            context.canvas.height = height;\n          }\n          context.drawImage(img, 0, 0, width, height);\n        });\n      };\n      img.src = imgData;\n    }\n    catch (e) {\n      console.log('encountered error while drawing video');\n      console.log('error: ' + e.message);\n    }\n\n    // update the last width and height\n    lastWidth = width;\n    lastHeight = height;\n  });\n};\n\n/**\n  ### prepareElement(opts, element) => HTMLElement\n\n  The `prepareElement` function is used to prepare the video container\n  for receiving a video stream.  If the plugin is able to work with\n  standard `<video>` and `<audio>` elements then a plugin should simply\n  not implement this function.\n\n**/\nvar prepareElement = exports.prepareElement = function(opts, element) {\n  var shouldReplace = (element instanceof HTMLVideoElement) ||\n      (element instanceof HTMLAudioElement);\n\n  // create our canvas\n  var canvas = document.createElement('canvas');\n  var srcStyle;\n  var bounds;\n\n  // if we should replace the element, then find the parent\n  var container = shouldReplace ? element.parentNode : element;\n  console.log('preparing element, created canvas');\n\n  // if we should replace the target element, then do that now\n  if (shouldReplace) {\n    console.log('getting computed style for the element');\n    srcStyle = window.getComputedStyle(element);\n\n    console.log('getting client bounding rect');\n    bounds = element.getBoundingClientRect();\n\n    console.log('setting w and h');\n    canvas.width = bounds.width;\n    canvas.height = bounds.height;\n\n    // add the classes from the source element to the canvas\n    canvas.className = element.className;\n\n    console.log('inserting canvas');\n    container.insertBefore(canvas, element);\n    container.removeChild(element);\n  }\n  // if we have an existing DOM node, then append to the container\n  else if (container) {\n    container.appendChild(canvas);\n  }\n\n  return canvas;\n};\n\n/* peer connection plugin interfaces */\n\nexports.createIceCandidate = function(opts) {\n  console.log('creating ice candidate, keys: ' + Object.keys(opts).join(' '));\n\n  return getRTCIceCandidate({\n    sdpMLineIndex: (opts || {}).sdpMLineIndex,\n    candidate: (opts || {}).candidate\n  });\n};\n\nexports.createConnection = function(config, constraints) {\n  config.iceServers = (config.iceServers || []).map(function(details) {\n    var url = (details || {}).url;\n    console.log('specifying ice url: ' + url);\n\n    return { url: url };\n  });\n\n  return new ProxyPeerConnection(getPeerConnection(config, constraints));\n};\n\nexports.createSessionDescription = function(opts) {\n  return getRTCSessionDescription(opts);\n};\n\n// listen for deviceready in case it happens before the plugin is called\nif (typeof document != 'undefined') {\n  document.addEventListener('deviceready', function() {\n    deviceReady = true;\n  });\n}\n",
    "var EventEmitter = require('eventemitter3');\nvar extend = require('cog/extend');\n\n/**\n  # rtc-proxy\n\n  This is a set of simple proxy classes that are designed to provide a\n  minimal layer between a WebRTC plugin and browser run JS.\n\n  ## Why?\n\n  This package exists because during the development of an iOS plugin, we\n  have found that frameworks such as angular don't work as nicely with\n  the plugin interface.  Primarily the problem is that Angular is unable\n  to get any metainformation about the object (using `Object.keys` or\n  similar).\n\n  This layer provides that information when required.\n\n**/\nmodule.exports = function(prot, methods, attributes, events) {\n\n  function capEvents(target, name) {\n    var events = emitter(target);\n\n    if (typeof target.__orig['on' + name] != 'function') {\n      target.__orig['on' + name] = function() {\n        events.emit.apply(events, [name].concat([].slice.call(arguments)));\n      };\n    }\n\n    return events;\n  }\n\n  function emitter(target) {\n    if (! target.__emitter) {\n      target.__emitter = new EventEmitter();\n    }\n\n    return target.__emitter;\n  }\n\n  // patch methods\n  (methods || []).forEach(function(method) {\n    prot[method] = function() {\n      var fn = this.__orig && this.__orig[method];\n\n      if (typeof fn == 'function') {\n        return fn.apply(this.__orig, arguments);\n      }\n\n      console.warn('could not invoke: ' + method);\n    };\n  });\n\n  // patch properties\n  (attributes || []).forEach(function(attrData) {\n    var key = attrData[0];\n    var flags = extend({\n      get: function() {\n        return this.__orig && this.__orig[key];\n      }\n    }, attrData[1]);\n\n    if (flags.writable && (! flags.set)) {\n      flags.set = function(value) {\n        if (this.__orig) {\n          this.__orig[key] = value;\n        }\n      }\n    }\n\n    Object.defineProperty(prot, key, flags);\n  });\n\n  (events || []).forEach(function(name) {\n    Object.defineProperty(prot, 'on' + name, {\n      get: function() {\n        return emitter(this).listeners(name)[0];\n      },\n\n      set: function(handler) {\n        var events = capEvents(this, name);\n\n        if (! handler) {\n          return events.removeAllListeners(name);\n        }\n\n        events.on(name, handler);\n      }\n    });\n  });\n\n  if (events) {\n    prot.addEventListener = function(name, handler) {\n      capEvents(this, name).on(name, handler);\n    };\n\n    prot.removeEventListener = function(name, handler) {\n      emitter(this).removeListener(name, handler);\n    };\n  }\n\n  return prot;\n};\n",
    "var proxy = require('./index');\n\nfunction ProxyMediaStream(original) {\n  if (! (this instanceof ProxyMediaStream)) {\n    return new ProxyMediaStream(original);\n  }\n\n  this.__orig = original;\n\n  proxy(\n    this,\n    [],\n    [\n      [ 'id', { enumerable: true } ],\n      [ 'ended', { enumerable: true } ]\n    ]\n  );\n}\n\nmodule.exports = ProxyMediaStream;\nvar prot = proxy(\n  ProxyMediaStream.prototype,\n  // methods\n  [\n    'getAudioTracks',\n    'getVideoTracks',\n    'getTrackById',\n    'addTrack',\n    'removeTrack'\n  ],\n\n  // properties [ name, attributes ]\n  [],\n\n  // events\n  [\n    'ended',\n    'addtrack',\n    'removetrack'\n  ]\n);\n\nprot.clone = function() {\n  return new ProxyMediaStream(this.__orig);\n};\n",
    "/* jshint node: true */\n'use strict';\n\n/**\n## cog/extend\n\n```js\nvar extend = require('cog/extend');\n```\n\n### extend(target, *)\n\nShallow copy object properties from the supplied source objects (*) into\nthe target object, returning the target object once completed:\n\n```js\nextend({ a: 1, b: 2 }, { c: 3 }, { d: 4 }, { b: 5 }));\n```\n\nSee an example on [requirebin](http://requirebin.com/?gist=6079475).\n**/\nmodule.exports = function(target) {\n  [].slice.call(arguments, 1).forEach(function(source) {\n    if (! source) {\n      return;\n    }\n\n    for (var prop in source) {\n      target[prop] = source[prop];\n    }\n  });\n\n  return target;\n};",
    "'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n\n  for (var i = 0, l = this._events[event].length, ee = []; i < l; i++) {\n    ee.push(this._events[event][i].fn);\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , length = listeners.length\n    , len = arguments.length\n    , ee = listeners[0]\n    , args\n    , i, j;\n\n  if (1 === length) {\n    if (ee.once) this.removeListener(event, ee.fn, true);\n\n    switch (len) {\n      case 1: return ee.fn.call(ee.context), true;\n      case 2: return ee.fn.call(ee.context, a1), true;\n      case 3: return ee.fn.call(ee.context, a1, a2), true;\n      case 4: return ee.fn.call(ee.context, a1, a2, a3), true;\n      case 5: return ee.fn.call(ee.context, a1, a2, a3, a4), true;\n      case 6: return ee.fn.call(ee.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    ee.fn.apply(ee.context, args);\n  } else {\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = [];\n  this._events[event].push(new EE( fn, context || this ));\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = [];\n  this._events[event].push(new EE(fn, context || this, true ));\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) for (var i = 0, length = listeners.length; i < length; i++) {\n    if (listeners[i].fn !== fn && listeners[i].once !== once) {\n      events.push(listeners[i]);\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) this._events[event] = events;\n  else this._events[event] = null;\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) this._events[event] = null;\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\nif ('object' === typeof module && module.exports) {\n  module.exports = EventEmitter;\n}\n",
    "var proxy = require('./index');\nvar ProxyMediaStream = require('./mediastream');\n\nfunction ProxyPeerConnection(original) {\n  if (! (this instanceof ProxyPeerConnection)) {\n    return new ProxyPeerConnection(original);\n  }\n\n  this.__orig = original;\n\n  proxy(\n    this,\n    [],\n    [\n      [ 'localDescription', { enumerable: true } ],\n      [ 'remoteDescription', { enumerable: true } ],\n      [ 'signalingState', { enumerable: true } ],\n      [ 'iceGatheringState', { enumerable: true } ],\n      [ 'iceConnectionState', { enumerable: true } ]\n    ]\n  );\n}\n\nmodule.exports = ProxyPeerConnection;\n\nvar prot = proxy(\n  ProxyPeerConnection.prototype,\n\n  // methods\n  [\n    'createOffer',\n    'createAnswer',\n    'createDataChannel',\n    'setLocalDescription',\n    'setRemoteDescription',\n    'updateIce',\n    'addIceCandidate',\n    'close'\n  ],\n\n  // properties [ name, readonly? ]\n  [],\n\n  // events\n  [\n    'negotiationneeded',\n    'icecandidate',\n    'signalingstatechange',\n    'addstream',\n    'removestream',\n    'iceconnectionstatechange',\n    'datachannel'\n  ]\n);\n\nprot.addStream = function(stream) {\n  if (! stream) {\n    return;\n  }\n\n  return this.__orig.addStream(stream.__orig || stream);\n};\n\nprot.removeStream = function(stream) {\n  if (! stream) {\n    return;\n  }\n\n  return this.__orig.removeStream(stream.__orig || stream);\n};\n\nprot.getLocalStreams = function() {\n  return this.__orig.getLocalStreams().map(ProxyMediaStream);\n};\n\nprot.getRemoteStreams = function() {\n  return this.__orig.getRemoteStreams().map(ProxyMediaStream);\n};\n\nprot.getStreamById = function(id) {\n  var stream = this.__orig.getStreamById(id);\n\n  if (stream) {\n    stream = new ProxyMediaStream(stream);\n  }\n\n  return stream;\n};\n"
  ]
}