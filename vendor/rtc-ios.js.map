{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "index.js",
    "node_modules/fdom/raf.js",
    "node_modules/objectfit/contain.js",
    "node_modules/objectfit/cover.js",
    "node_modules/objectfit/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/* jshint node: true */\n'use strict';\n\nvar objectfit = require('objectfit');\nvar raf = require('fdom/raf');\nvar reNICTAUserAgent = /\\(iOS\\;.*Mobile\\/NICTA/;\nvar deviceReady = false;\nvar initialized = false;\n\n/**\n  # rtc-plugin-nicta-ios\n\n  This is a plugin for bridging the functionality provided by a NICTA iOS webkit plugin.\n  While this plugin integration layer is provided opensource, the iOS plugin itself is\n  part of http://build.rtc.io/.\n\n  ## Getting More Information\n\n  If you are after more information regarding the plugin feel free to\n  reach out to either of the following people, and we will do our best\n  to answer your questions:\n\n  - Damon Oehlman <damon.oehlman@nicta.com.au>\n  - Silvia Pfeiffer <silvia.pfeiffer@nicta.com.au>\n\n**/\n\n/**\n  ### supported(platform) => Boolean\n\n  The supported function returns true if the platform (as detected using\n  `rtc-core/detect`) is compatible with the plugin. By doing this prelimenary\n  detection you can specify a number of plugins to be loaded but only\n  the first the is supported on the current platform will be used.\n\n**/\nexports.supported = function(platform) {\n  return typeof navigator != 'undefined' && reNICTAUserAgent.test(navigator.userAgent);\n};\n\n/**\n  ### init(callback)\n\n  The `init` function is reponsible for ensuring that the current HTML\n  document is prepared correctly.\n\n**/\nvar init = exports.init = function(opts, callback) {\n  function ready(evt) {\n    var oldLogger;\n\n    if (initialized) {\n      return callback();\n    }\n\n    document.removeEventListener('deviceready', ready);\n\n    // override the console.log implementation to report back to the iOS console\n    oldLogger = window.console.log;\n    window.console.log = function(msg) {\n      var nativeMessage = [].slice.call(arguments).join(' ');\n\n      try {\n        NativeLog(nativeMessage);\n      }\n      catch (e) {\n        alert(nativeMessage);\n      }\n\n      oldLogger.apply(window.console, arguments);\n    };\n\n    if (typeof getUserMedia == 'function') {\n      navigator.getUserMedia = function(constraints, successCb, failureCb) {\n        getUserMedia(constraints, successCb, failureCb);\n      };\n    }\n\n    initialized = true;\n    console.log('iOS plugin initialized, getUserMedia available = ' + (!!navigator.getUserMedia));\n\n    callback();\n  }\n\n  // check if we missed the device ready\n  deviceReady = deviceReady || typeof getPeerConnection != 'undefined';\n\n  // if the device is ready, then initialise immediately\n  if (deviceReady) {\n    // initialise after a 10ms timeout\n    return setTimeout(ready, 10);\n  }\n\n  // wait for the device ready call\n  document.addEventListener('deviceready', ready);\n};\n\nexports.attach = function(stream, opts) {\n  var canvas = prepareElement(opts, (opts || {}).el || (opts || {}).target);\n  var context = canvas.getContext('2d');\n  var maxfps = parseInt((opts || {}).maxfps, 10) || 0;\n  var drawInterval = maxfps && (1000 / maxfps);\n  var lastDraw = 0;\n  var fitter;\n  var img;\n\n  function handleImageData(imgData, width, height) {\n    var tick = Date.now();\n    if (drawInterval && (tick < lastDraw + drawInterval)) {\n      return;\n    }\n\n    img = new Image();\n    img.onload = function() {\n      raf(drawImage);\n    };\n    img.src = imgData;\n  }\n\n  function handleWindowResize(evt) {\n    var bounds = canvas.getBoundingClientRect();\n    var style = window.getComputedStyle(canvas);\n    var fit = objectfit[style.objectFit] || objectfit.contain;\n\n    canvas.width = bounds.width;\n    canvas.height = bounds.height;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    // get the fitter function\n    fitter = fit([0, 0, bounds.width, bounds.height]);\n    drawImage();\n  }\n\n  function drawImage() {\n    if (! img) {\n      return;\n    }\n\n    context.drawImage.apply(context, [img].concat(fitter([0, 0, img.width, img.height])));\n    lastDraw = Date.now();\n  }\n\n  // handle window resizes and resize the canvas appropriately\n  window.addEventListener('resize', handleWindowResize, false);\n  window.addEventListener('load', handleWindowResize, false);\n\n  iOSRTC_onDrawRegi(stream, handleImageData);\n\n  // handle the initial window resize\n  setTimeout(handleWindowResize, 10);\n\n  return canvas;\n};\n\n/**\n  ### prepareElement(opts, element) => HTMLElement\n\n  The `prepareElement` function is used to prepare the video container\n  for receiving a video stream.  If the plugin is able to work with\n  standard `<video>` and `<audio>` elements then a plugin should simply\n  not implement this function.\n\n**/\nvar prepareElement = exports.prepareElement = function(opts, element) {\n  var shouldReplace = (element instanceof HTMLVideoElement) ||\n      (element instanceof HTMLAudioElement);\n\n  // create our canvas\n  var canvas = document.createElement('canvas');\n  var srcStyle;\n  var bounds;\n\n  // if we should replace the element, then find the parent\n  var container = shouldReplace ? element.parentNode : element;\n  console.log('preparing element, created canvas');\n\n  // if we should replace the target element, then do that now\n  if (shouldReplace && element.parentNode) {\n    // add the classes from the source element to the canvas\n    canvas.className = element.className;\n\n    console.log('inserting canvas');\n    container.insertBefore(canvas, element);\n    container.removeChild(element);\n  }\n  // if we have an existing DOM node, then append to the container\n  else if (container) {\n    container.appendChild(canvas);\n  }\n\n  return canvas;\n};\n\n/* peer connection plugin interfaces */\n\nexports.createIceCandidate = function(opts) {\n  console.log('creating ice candidate, keys: ' + Object.keys(opts).join(' '));\n\n  return getRTCIceCandidate({\n    sdpMLineIndex: (opts || {}).sdpMLineIndex,\n    candidate: (opts || {}).candidate\n  });\n};\n\nexports.createConnection = function(config, constraints) {\n  return getPeerConnection(config, constraints);\n};\n\nexports.createSessionDescription = function(opts) {\n  return getRTCSessionDescription(opts);\n};\n\n// listen for deviceready in case it happens before the plugin is called\nif (typeof document != 'undefined') {\n  document.addEventListener('deviceready', function() {\n    deviceReady = true;\n  });\n}\n",
    "/* jshint node: true */\n/* global window: false */\n'use strict';\n\nvar TEST_PROPS = ['r', 'webkitR', 'mozR', 'oR', 'msR'];\n\n/**\n  ### raf(callback)\n\n  Request animation frame helper.\n\n  <<< examples/raf.js\n\n**/\n\nmodule.exports = typeof window != 'undefined' && (function() {\n  for (var ii = 0; ii < TEST_PROPS.length; ii++) {\n    window.animFrame = window.animFrame ||\n      window[TEST_PROPS[ii] + 'equestAnimationFrame'];\n  } // for\n\n  return animFrame;\n})();",
    "/**\n  ### contain\n\n  Use [letterboxing](http://en.wikipedia.org/wiki/Letterbox) or\n  [pillarboxing](http://en.wikipedia.org/wiki/Pillar_box_(film)) to resize\n  an object to fit within another containing rect, without affecting the\n  aspect ratio.\n\n**/\nmodule.exports = function(container, subject) {\n  var cw = container[2];\n  var ch = container[3];\n  var cr = cw / ch;\n\n  function contain(subject) {\n    var sw = subject[2];\n    var sh = subject[3];\n    var sr = sw / sh;\n    var result = [];\n\n    if (sr < cr) {\n      result[2] = (ch * sr) | 0;\n      result[3] = ch;\n      result[0] = (cw - result[2]) >> 1;\n      result[1] = 0;\n    }\n    else {\n      result[2] = cw;\n      result[3] = (cw / sr) | 0;\n      result[0] = 0;\n      result[1] = (ch - result[3]) >> 1;\n    }\n\n    // apply the offset\n    result[0] += container[0];\n    result[1] += container[1];\n\n    return result;\n  }\n\n  return subject ? contain(subject) : contain;\n};\n",
    "/**\n  ### cover\n\n  Ensure the subject completely fills the container leaving no whitespace\n  visible in the container.\n\n**/\nmodule.exports = function(container, subject) {\n  var cw = container[2];\n  var ch = container[3];\n  var cr = cw / ch;\n\n  function fit(subject) {\n    var sw = subject[2];\n    var sh = subject[3];\n    var sr = sw / sh;\n    var result = [];\n\n    if (sr < cr) {\n      result[2] = cw;\n      result[3] = (cw / sr) | 0;\n      result[0] = 1;\n      result[1] = -(result[3] - ch) >> 1;\n    }\n    else {\n      result[2] = (ch * sr) | 0;\n      result[3] = ch;\n      result[0] = -(result[2] - cw) >> 1;\n      result[1] = 0;\n    }\n\n    // apply the offset\n    result[0] += container[0];\n    result[1] += container[1];\n\n    return result;\n  }\n\n  return subject ? fit(subject) : fit;\n};\n",
    "/**\n  # objectfit\n\n  This is a suite of functions for fitting (possibly overflowing depending on\n  the technique) one rectangular shape into another rectangular region,\n  preserving aspect ratio.\n\n  ## Example Usage\n\n  Displayed below is an example of drawing an image on a canvas using the\n  `objectfit/contain` function.  It should be noted that as the functions\n  all use the same function signature, `objectfit/cover` could be used in\n  it's place.\n\n  <<< examples/contain.js\n\n  ## Reference\n\n  All objectfit functions use the following function signature:\n\n  ```\n  fit(container, => subject) => [x, y, width, height]\n  ```\n\n  ## Implementations\n\n**/\nexports.contain = require('./contain');\nexports.cover = require('./cover');\n"
  ]
}