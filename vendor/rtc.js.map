{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "defaultconfig.js",
    "index.js",
    "node_modules/browserify/node_modules/events/events.js",
    "node_modules/browserify/node_modules/process/browser.js",
    "node_modules/cog/defaults.js",
    "node_modules/cog/extend.js",
    "node_modules/cog/getable.js",
    "node_modules/cog/jsonparse.js",
    "node_modules/cog/logger.js",
    "node_modules/cog/throttle.js",
    "node_modules/fdom/append.js",
    "node_modules/fdom/classtweak.js",
    "node_modules/fdom/qsa.js",
    "node_modules/kgo/kgo.js",
    "node_modules/kgo/run.js",
    "node_modules/rtc-attach/index.js",
    "node_modules/rtc-capture/index.js",
    "node_modules/rtc-core/detect.js",
    "node_modules/rtc-core/node_modules/detect-browser/browser.js",
    "node_modules/rtc-core/plugin.js",
    "node_modules/rtc-quickconnect/index.js",
    "node_modules/rtc-quickconnect/node_modules/mbus/index.js",
    "node_modules/rtc-quickconnect/node_modules/mbus/node_modules/array-trie/node_modules/binary-search-bounds/search-bounds.js",
    "node_modules/rtc-quickconnect/node_modules/mbus/node_modules/array-trie/trie.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/browser.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/defaults.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/handlers/announce.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/handlers/index.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/handlers/leave.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/node_modules/cuid/dist/browser-cuid.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/node_modules/formatter/index.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/node_modules/formatter/mods.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/primus-loader.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/processor.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-signaller/signaller.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/cleanup.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/couple.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/detect.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/generators.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/index.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/monitor.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/node_modules/rtc-taskqueue/index.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/node_modules/rtc-taskqueue/node_modules/priorityqueuejs/index.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/node_modules/rtc-taskqueue/node_modules/rtc-sdpclean/index.js",
    "node_modules/rtc-quickconnect/node_modules/rtc-tools/node_modules/rtc-taskqueue/node_modules/rtc-validator/candidate.js",
    "node_modules/whisk/chain.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "// a default configuration that is used by the rtc package\nmodule.exports = {\n  // simple constraints for defaults\n  constraints: {\n    video: true,\n    audio: true\n  },\n\n  // use the public switchboard for signalling\n  signaller: '//switchboard.rtc.io',\n\n  // no room is defined by default\n  // rtc-quickconnect will autogenerate using a location.hash\n  room: undefined,\n\n  // specify ice servers or a generator function to create ice servers\n  ice: [],\n\n  // any data channels that we want to create for the conference\n  // by default a chat channel is created, but other channels can be added also\n  // additionally options can be supplied to customize the data channel config\n  // see: <http://w3c.github.io/webrtc-pc/#idl-def-RTCDataChannelInit>\n  channels: {\n    chat: true\n  },\n\n  // the selector that will be used to identify the localvideo container\n  localContainer: '#l-video',\n\n  // the selector that will be used to identify the remotevideo container\n  remoteContainer: '#r-video',\n\n  // should we atempt to load any plugins?\n  plugins: [],\n\n  // common options overrides that are used across rtc.io packages\n  options: {}\n};\n",
    "var defaults = require('cog/defaults');\nvar extend = require('cog/extend');\nvar attach = require('rtc-attach');\nvar capture = require('rtc-capture');\nvar quickconnect = require('rtc-quickconnect');\nvar chain = require('whisk/chain');\nvar append = require('fdom/append');\nvar tweak = require('fdom/classtweak');\nvar qsa = require('fdom/qsa');\nvar kgo = require('kgo');\n\nmodule.exports = function(config) {\n  var conference;\n\n  // extend our configuration with the defaults\n  config = defaults({}, config, require('./defaultconfig.js'));\n\n  // create our conference instance\n  conference = quickconnect(\n    config.signaller,\n    extend({\n      room: config.room,\n      ice: config.ice,\n      plugins: config.plugins,\n      expectedLocalStreams: config.constraints ? 1 : 0\n    }, config.options)\n  );\n\n  conference\n  .on('call:ended', removeRemoteVideos)\n  .on('stream:added', remoteVideo(conference, config));\n\n  Object.keys(config.channels || {}).forEach(function(name) {\n    var channelConfig = config.channels[name];\n\n    conference.createDataChannel(name, channelConfig === true ? null : channelConfig);\n  });\n\n  // if we have constraints, then capture video\n  if (config.constraints) {\n    localVideo(conference, config);\n  }\n\n  return conference;\n}\n\nfunction flagOwnership(peerId) {\n  return function(el) {\n    el.dataset.peer = peerId;\n  };\n};\n\nfunction localVideo(qc, config) {\n  // use kgo to help with flow control\n  kgo(config)\n  ('capture', [ 'constraints', 'options' ], capture)\n  ('attach', [ 'capture', 'options' ], attach.local)\n  ('render-local', [ 'attach' ], chain([\n    tweak('+rtc'),\n    tweak('+localvideo'),\n    append.to((config || {}).localContainer || '#l-video')\n  ]))\n  ('start-conference', [ 'capture' ], qc.addStream)\n  .on('error', reportError(qc, config));\n}\n\nfunction remoteVideo(qc, config) {\n  return function(id, stream) {\n    kgo({ stream: stream })\n    ('attach', [ 'stream' ], attach)\n    ('render-remote', [ 'attach' ], chain([\n      tweak('+rtc'),\n      tweak('+remotevideo'),\n      flagOwnership(id),\n      append.to((config || {}).remoteContainer || '#r-video')\n    ]))\n    .on('error', reportError(qc, config));\n  };\n}\n\nfunction removeRemoteVideos(id) {\n  qsa('[data-peer=\"' + id + '\"]').forEach(function(el) {\n    el.parentNode.removeChild(el);\n  });\n}\n\nfunction reportError(qc, config) {\n  return function(err) {\n    console.error(err);\n  };\n}\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n",
    "// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n",
    "/* jshint node: true */\n'use strict';\n\n/**\n## cog/defaults\n\n```js\nvar defaults = require('cog/defaults');\n```\n\n### defaults(target, *)\n\nShallow copy object properties from the supplied source objects (*) into\nthe target object, returning the target object once completed.  Do not,\nhowever, overwrite existing keys with new values:\n\n```js\ndefaults({ a: 1, b: 2 }, { c: 3 }, { d: 4 }, { b: 5 }));\n```\n\nSee an example on [requirebin](http://requirebin.com/?gist=6079475).\n**/\nmodule.exports = function(target) {\n  // ensure we have a target\n  target = target || {};\n\n  // iterate through the sources and copy to the target\n  [].slice.call(arguments, 1).forEach(function(source) {\n    if (! source) {\n      return;\n    }\n\n    for (var prop in source) {\n      if (target[prop] === void 0) {\n        target[prop] = source[prop];\n      }\n    }\n  });\n\n  return target;\n};",
    "/* jshint node: true */\n'use strict';\n\n/**\n## cog/extend\n\n```js\nvar extend = require('cog/extend');\n```\n\n### extend(target, *)\n\nShallow copy object properties from the supplied source objects (*) into\nthe target object, returning the target object once completed:\n\n```js\nextend({ a: 1, b: 2 }, { c: 3 }, { d: 4 }, { b: 5 }));\n```\n\nSee an example on [requirebin](http://requirebin.com/?gist=6079475).\n**/\nmodule.exports = function(target) {\n  [].slice.call(arguments, 1).forEach(function(source) {\n    if (! source) {\n      return;\n    }\n\n    for (var prop in source) {\n      target[prop] = source[prop];\n    }\n  });\n\n  return target;\n};",
    "/**\n  ## cog/getable\n\n  Take an object and provide a wrapper that allows you to `get` and\n  `set` values on that object.\n\n**/\nmodule.exports = function(target) {\n  function get(key) {\n    return target[key];\n  }\n\n  function set(key, value) {\n    target[key] = value;\n  }\n\n  function remove(key) {\n    return delete target[key];\n  }\n\n  function keys() {\n    return Object.keys(target);\n  };\n\n  function values() {\n    return Object.keys(target).map(function(key) {\n      return target[key];\n    });\n  };\n\n  if (typeof target != 'object') {\n    return target;\n  }\n\n  return {\n    get: get,\n    set: set,\n    remove: remove,\n    delete: remove,\n    keys: keys,\n    values: values\n  };\n};\n",
    "/* jshint node: true */\n'use strict';\n\n/**\n  ## cog/jsonparse\n\n  ```js\n  var jsonparse = require('cog/jsonparse');\n  ```\n\n  ### jsonparse(input)\n\n  This function will attempt to automatically detect stringified JSON, and\n  when detected will parse into JSON objects.  The function looks for strings\n  that look and smell like stringified JSON, and if found attempts to\n  `JSON.parse` the input into a valid object.\n\n**/\nmodule.exports = function(input) {\n  var isString = typeof input == 'string' || (input instanceof String);\n  var reNumeric = /^\\-?\\d+\\.?\\d*$/;\n  var shouldParse ;\n  var firstChar;\n  var lastChar;\n\n  if ((! isString) || input.length < 2) {\n    if (isString && reNumeric.test(input)) {\n      return parseFloat(input);\n    }\n\n    return input;\n  }\n\n  // check for true or false\n  if (input === 'true' || input === 'false') {\n    return input === 'true';\n  }\n\n  // check for null\n  if (input === 'null') {\n    return null;\n  }\n\n  // get the first and last characters\n  firstChar = input.charAt(0);\n  lastChar = input.charAt(input.length - 1);\n\n  // determine whether we should JSON.parse the input\n  shouldParse =\n    (firstChar == '{' && lastChar == '}') ||\n    (firstChar == '[' && lastChar == ']') ||\n    (firstChar == '\"' && lastChar == '\"');\n\n  if (shouldParse) {\n    try {\n      return JSON.parse(input);\n    }\n    catch (e) {\n      // apparently it wasn't valid json, carry on with regular processing\n    }\n  }\n\n\n  return reNumeric.test(input) ? parseFloat(input) : input;\n};",
    "/* jshint node: true */\n'use strict';\n\n/**\n  ## cog/logger\n\n  ```js\n  var logger = require('cog/logger');\n  ```\n\n  Simple browser logging offering similar functionality to the\n  [debug](https://github.com/visionmedia/debug) module.\n\n  ### Usage\n\n  Create your self a new logging instance and give it a name:\n\n  ```js\n  var debug = logger('phil');\n  ```\n\n  Now do some debugging:\n\n  ```js\n  debug('hello');\n  ```\n\n  At this stage, no log output will be generated because your logger is\n  currently disabled.  Enable it:\n\n  ```js\n  logger.enable('phil');\n  ```\n\n  Now do some more logger:\n\n  ```js\n  debug('Oh this is so much nicer :)');\n  // --> phil: Oh this is some much nicer :)\n  ```\n\n  ### Reference\n**/\n\nvar active = [];\nvar unleashListeners = [];\nvar targets = [ console ];\n\n/**\n  #### logger(name)\n\n  Create a new logging instance.\n**/\nvar logger = module.exports = function(name) {\n  // initial enabled check\n  var enabled = checkActive();\n\n  function checkActive() {\n    return enabled = active.indexOf('*') >= 0 || active.indexOf(name) >= 0;\n  }\n\n  // register the check active with the listeners array\n  unleashListeners[unleashListeners.length] = checkActive;\n\n  // return the actual logging function\n  return function() {\n    var args = [].slice.call(arguments);\n\n    // if we have a string message\n    if (typeof args[0] == 'string' || (args[0] instanceof String)) {\n      args[0] = name + ': ' + args[0];\n    }\n\n    // if not enabled, bail\n    if (! enabled) {\n      return;\n    }\n\n    // log\n    targets.forEach(function(target) {\n      target.log.apply(target, args);\n    });\n  };\n};\n\n/**\n  #### logger.reset()\n\n  Reset logging (remove the default console logger, flag all loggers as\n  inactive, etc, etc.\n**/\nlogger.reset = function() {\n  // reset targets and active states\n  targets = [];\n  active = [];\n\n  return logger.enable();\n};\n\n/**\n  #### logger.to(target)\n\n  Add a logging target.  The logger must have a `log` method attached.\n\n**/\nlogger.to = function(target) {\n  targets = targets.concat(target || []);\n\n  return logger;\n};\n\n/**\n  #### logger.enable(names*)\n\n  Enable logging via the named logging instances.  To enable logging via all\n  instances, you can pass a wildcard:\n\n  ```js\n  logger.enable('*');\n  ```\n\n  __TODO:__ wildcard enablers\n**/\nlogger.enable = function() {\n  // update the active\n  active = active.concat([].slice.call(arguments));\n\n  // trigger the unleash listeners\n  unleashListeners.forEach(function(listener) {\n    listener();\n  });\n\n  return logger;\n};",
    "/* jshint node: true */\n'use strict';\n\n/**\n  ## cog/throttle\n\n  ```js\n  var throttle = require('cog/throttle');\n  ```\n\n  ### throttle(fn, delay, opts)\n\n  A cherry-pickable throttle function.  Used to throttle `fn` to ensure\n  that it can be called at most once every `delay` milliseconds.  Will\n  fire first event immediately, ensuring the next event fired will occur\n  at least `delay` milliseconds after the first, and so on.\n\n**/\nmodule.exports = function(fn, delay, opts) {\n  var lastExec = (opts || {}).leading !== false ? 0 : Date.now();\n  var trailing = (opts || {}).trailing;\n  var timer;\n  var queuedArgs;\n  var queuedScope;\n\n  // trailing defaults to true\n  trailing = trailing || trailing === undefined;\n  \n  function invokeDefered() {\n    fn.apply(queuedScope, queuedArgs || []);\n    lastExec = Date.now();\n  }\n\n  return function() {\n    var tick = Date.now();\n    var elapsed = tick - lastExec;\n\n    // always clear the defered timer\n    clearTimeout(timer);\n\n    if (elapsed < delay) {\n      queuedArgs = [].slice.call(arguments, 0);\n      queuedScope = this;\n\n      return trailing && (timer = setTimeout(invokeDefered, delay - elapsed));\n    }\n\n    // call the function\n    lastExec = tick;\n    fn.apply(this, arguments);\n  };\n};",
    "/* jshint node: true */\n'use strict';\n\n/**\n  ### append\n\n  ```js\n  var append = require('fdom/append');\n  ```\n**/\n\nvar append = module.exports = function() {\n  console.log('not yet implemented');\n\n  return false;\n};\n\n/**\n  #### append.to(target, => child) => child\n\n  Append the specified `child` element to the `target` element using the\n  familiar `appendChild` method of the target.\n\n  <<< examples/append-to.js\n\n**/\n\nappend.to = function(target, child) {\n\n  function append(el) {\n    var t = target;\n    if (typeof t == 'string' || (t instanceof String)) {\n      t = document.querySelector(t);\n    }\n\n    if (t && typeof t.appendChild == 'function') {\n      t.appendChild(el);\n      return el;\n    }\n  }\n\n  return child ? append(child) : append;\n};\n",
    "/* jshint node: true */\n'use strict';\n\nvar reDelim = /[\\s\\,]\\s*/;\nvar opMappings = {\n  '+': 'add',\n  '-': 'remove',\n  '~': 'toggle',\n  '!': 'toggle'\n};\n\n/**\n  ### classtweak(operations, => el)\n\n  A functional helper for making\n  [classList](http://www.w3.org/TR/domcore/#dom-element-classlist)\n  modifications to elements, supporting partial application.\n\n  <<< examples/classtweak.js\n\n**/\nmodule.exports = function(mods, element) {\n  var rules = mods.trim().split(reDelim)\n    // create the rule objects\n    .map(function(rule) {\n      return {\n        op: opMappings[rule.charAt(0)],\n        cls: rule.slice(1)\n      };\n    })\n    // removed non mapped operation codes\n    .filter(function(rule) {\n      return rule.op;\n    });\n\n  function tweak(el) {\n    if (! el.classList) {\n      return el;\n    }\n\n    // iterate through the rules and apply the changes\n    rules.forEach(function(rule) {\n      el.classList[rule.op](rule.cls);\n    });\n\n    return el;\n  }\n\n  return element ? tweak(element) : tweak;\n};",
    "/* jshint node: true */\n/* global document: false */\n'use strict';\n\nvar classSelectorRE = /^\\.([\\w\\-]+)$/;\nvar idSelectorRE = /^#([\\w\\-]+)$/;\nvar tagSelectorRE = /^[\\w\\-]+$/;\n\n/**\n  ### qsa(selector, scope?)\n\n  This function is used to get the results of the querySelectorAll output\n  in the fastest possible way.  This code is very much based on the\n  implementation in\n  [zepto](https://github.com/madrobby/zepto/blob/master/src/zepto.js#L104),\n  but perhaps not quite as terse.\n\n  <<< examples/qsa.js\n\n**/\nmodule.exports = function(selector, scope) {\n  var idSearch;\n\n  // default the element to the document\n  scope = scope || document;\n\n  // determine whether we are doing an id search or not\n  idSearch = scope === document && idSelectorRE.test(selector);\n\n  // perform the search\n  return idSearch ?\n    // we are doing an id search, return the element search in an array\n    [scope.getElementById(RegExp.$1)] :\n    // not an id search, call the appropriate selector\n    Array.prototype.slice.call(\n        classSelectorRE.test(selector) ?\n          scope.getElementsByClassName(RegExp.$1) :\n            tagSelectorRE.test(selector) ?\n              scope.getElementsByTagName(selector) :\n              scope.querySelectorAll(selector)\n    );\n};",
    "var run = require('./run'),\n    EventEmitter = require('events').EventEmitter,\n    fnRegex = /^function.*?\\((.*?)\\)/;\n\nvar defer = typeof setImmediate === 'function' ? setImmediate : setTimeout;\n\nfunction newKgo(){\n    var returnlessId = 0,\n        tasks = {},\n        results = {},\n        errorHandlers = {},\n        inFlight,\n        defaultsDefined;\n\n    function kgoFn(name, dependencies, fn){\n        if(inFlight){\n            throw \"No tasks or defaults may be set after kgo is in flight\";\n        }\n\n        if(arguments.length === 1 && name !== null && typeof name === 'object'){\n            if(defaultsDefined){\n                throw \"Defaults may be defined only once per kgo\";\n            }\n\n            for(var key in name){\n                if(key in tasks){\n                    throw \"A task is already defined for \" + key;\n                }\n                results[key] = name[key];\n            }\n            defaultsDefined = true;\n            return kgoFn;\n        }\n\n        if(typeof name !== 'string'){\n            fn = dependencies;\n            dependencies = name;\n            name = (returnlessId++).toString() + '__returnless';\n        }\n\n        if(typeof dependencies === 'function'){\n            fn = dependencies;\n            dependencies = [];\n        }\n\n        if(typeof fn !== 'function'){\n            throw new Error('No function provided for task number ' + Object.keys(tasks).length + ' (' + name + ')');\n        }\n\n        if(name in results){\n            throw \"A default with the same name as this task (\" + name + \") has already been set\";\n        }\n\n        tasks[name] = {\n            name: name,\n            args: dependencies,\n            fn: fn\n        };\n\n        return kgoFn;\n    }\n\n    for(var key in EventEmitter.prototype){\n        kgoFn[key] = EventEmitter.prototype[key];\n    }\n\n    kgoFn.apply(null, arguments);\n\n    defer(function(){\n        inFlight = true;\n        run(tasks, results, kgoFn);\n    });\n\n    return kgoFn;\n}\n\nmodule.exports = newKgo;",
    "var ignoreDependency = /^\\!.+/;\n\nfunction Step(task, args, done){\n    this._task = task;\n    this._args = args;\n    this._done = done;\n}\nStep.prototype._count = 1;\nStep.prototype._runs = 0;\nStep.prototype.run = function(){\n    var step = this,\n        results = [],\n        didError;\n\n    this._task.fn.apply(this, this._args.concat([function(error, result){\n        results.push(result);\n        step._runs++;\n        if(error){\n            didError = true;\n            step.done(error);\n        }else if(!didError && step._runs === step._count){\n            step.done(null, results);\n        }\n    }]));\n};\nStep.prototype.count = function(number){\n    this._parallel = true;\n    this._count = number;\n};\nStep.prototype.done = function(error, results){\n    if(error){\n        return this._done(error);\n    }\n    this._done(null, this._parallel ? results : results[0]);\n};\n\nfunction runTask(task, results, aboutToRun, done){\n    var name = task.name,\n        dependants = task.args,\n        taskFunction = task.fn,\n        args = [];\n\n    if(dependants){\n        for(var i = 0; i < dependants.length; i++) {\n            var dependantName = dependants[i],\n                ignore = dependantName.match(ignoreDependency);\n\n            if(ignore){\n                dependantName = dependantName.slice(1);\n            }\n\n            if(!(dependantName in results)){\n                return;\n            }\n\n            if(!ignore){\n                args.push(results[dependantName]);\n            }\n        }\n    }\n\n    var step = new Step(task, args, function(error, result){\n        done(name, error, result);\n    });\n\n    aboutToRun(name);\n    step.run();\n}\n\nfunction run(tasks, results, emitter){\n    var currentTask;\n\n    for(var key in tasks){\n        currentTask = tasks[key];\n\n        runTask(\n            currentTask,\n            results,\n            function(name){\n                delete tasks[name];\n            },\n            function(name, error, result){\n                if(error){\n                    emitter.emit('error', error, name);\n                    return;\n                }\n\n                results[name] = result;\n                run(tasks, results, emitter);\n            }\n        );\n    }\n}\n\nfunction cloneAndRun(tasks, results, emitter){\n    var todo = {};\n\n    for(var key in tasks){\n        todo[key] = tasks[key];\n    }\n\n    run(todo, results, emitter);\n}\n\nmodule.exports = cloneAndRun;",
    "var plugin = require('rtc-core/plugin');\nvar extend = require('cog/extend');\n\n/**\n  # rtc-attach\n\n  Roughly equivalent to the\n  [`attachMediaStream`](https://www.npmjs.org/package/attachmediastream)\n  package but with support for rtc.io plugins.  Also uses an error first\n  async API to allow plugins time to initialize.\n\n  ## Example Usage\n\n  <<< examples/simple.js\n\n  ## Example using Plugins\n\n  <<< examples/plugins.js\n\n  ## Reference\n\n  ### `attach(stream, opts?, callback)`\n\n  Attach `stream` to a HTML element that will render the content. The provided\n  `callback` follows the format of `fn(err, element)`.  While the async nature\n  of this package may seem odd, because a plugin may need time to initialize\n  this caters for this case in addition to standard usage in the browser.\n\n  - `autoplay` (default: `true`) - by default after the stream has been\n    attached to the element it will be played.  This is done by calling\n    the `play()` function on the element rather than relying on `autoplay`\n    attribute functionality.\n\n  - `el` (default: `null`) - if you with to supply an element to be used\n    instead of creating a new element to receive the stream specify it here.\n\n  - `muted` (default: `false`) - whether the created element should be muted\n    or not.  For local streams this should almost always, be true so consider\n    using the `attach.local` helper function for simple cases.\n\n  - `plugins` (default: `[]`) - specify one or more plugins that can be used\n    to render the media stream appropriate to the current platform in the\n    event that WebRTC and/or media capture is supported via a browser plugin.\n\n**/\nvar attach = module.exports = function(stream, opts, callback) {\n  var URL = typeof window != 'undefined' && window.URL;\n  var el;\n  var pinst;\n\n  if (typeof opts == 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  function attachToElement(s, o) {\n    var autoplay = (o || {}).autoplay;\n    var elType = 'audio';\n    var el = (o || {}).el;\n\n    // check the stream is valid\n    isValid = s && typeof s.getVideoTracks == 'function';\n\n    // determine the element type\n    if (isValid && s.getVideoTracks().length > 0) {\n      elType = 'video';\n    }\n\n    // prepare the element\n    el = el || document.createElement(elType);\n\n    // attach the stream\n    if (URL && URL.createObjectURL) {\n      el.src = URL.createObjectURL(stream);\n    }\n    else if (el.srcObject) {\n      el.srcObject = stream;\n    }\n    else if (el.mozSrcObject) {\n      el.mozSrcObject = stream;\n    }\n\n    if ((o || {}).muted) {\n      el.muted = true;\n      el.setAttribute('muted', '');\n    }\n\n    if (autoplay === undefined || autoplay) {\n      el.play();\n    }\n\n    return el;\n  }\n\n  // see if we are using a plugin\n  pinst = plugin((opts || {}).plugins);\n  if (pinst) {\n    return pinst.init(opts, function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (typeof pinst.attach != 'function') {\n        return callback(new Error('plugin must support the attach function'));\n      }\n\n      callback(null, pinst.attach(stream, opts));\n    });\n  }\n\n  callback(null, attachToElement(stream, opts));\n};\n\n/**\n  ### `attach.local(stream, opts?, callback)`\n\n  Attach a local stream with options appropriate for local streams:\n\n  - `muted`: `true`\n\n**/\nattach.local = function(stream, opts, callback) {\n  if (typeof opts == 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  attach(stream, extend({ muted: true }, opts), callback);\n};\n",
    "var plugin = require('rtc-core/plugin');\nvar detect = require('rtc-core/detect');\n\n// patch navigator getUserMedia\nnavigator.getUserMedia = navigator.getUserMedia ||\n  detect.call(navigator, 'getUserMedia');\n\n/**\n  # rtc-capture\n\n  Roughly equivalent to the\n  [`getUserMedia`](https://www.npmjs.org/package/getusermedia) package but with\n  support for rtc.io plugins.\n\n  ## Example Usage\n\n  <<< examples/simple.js\n\n  ## Example with using Plugins\n\n  <<< examples/plugins.js\n\n  ## Reference\n\n  ### `capture(constraints, opts?, callback)`\n\n  Capture media with the supplied `constraints`.  If an `opts` argument is\n  supplied look for plugins that may change the behaviour of the capture\n  operation.\n\n**/\nmodule.exports = function(constraints, opts, callback) {\n  var pinst;\n\n  function handleCapture(stream) {\n    callback(null, stream);\n  }\n\n  if (typeof opts == 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  // see if we are using a plugin\n  pinst = plugin((opts || {}).plugins);\n  if (pinst) {\n    return pinst.init(opts, function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (typeof navigator.getUserMedia != 'function') {\n        return callback(new Error('plugin does not support media capture'));\n      }\n\n      navigator.getUserMedia(constraints, handleCapture, callback);\n    });\n  }\n\n  if (typeof navigator.getUserMedia != 'function') {\n    return callback(new Error('getUserMedia not supported'));\n  }\n\n  navigator.getUserMedia(constraints, handleCapture, callback);\n};\n",
    "/* jshint node: true */\n/* global window: false */\n/* global navigator: false */\n\n'use strict';\n\nvar browser = require('detect-browser');\n\n/**\n  ### `rtc-core/detect`\n\n  A browser detection helper for accessing prefix-free versions of the various\n  WebRTC types.\n\n  ### Example Usage\n\n  If you wanted to get the native `RTCPeerConnection` prototype in any browser\n  you could do the following:\n\n  ```js\n  var detect = require('rtc-core/detect'); // also available in rtc/detect\n  var RTCPeerConnection = detect('RTCPeerConnection');\n  ```\n\n  This would provide whatever the browser prefixed version of the\n  RTCPeerConnection is available (`webkitRTCPeerConnection`,\n  `mozRTCPeerConnection`, etc).\n**/\nvar detect = module.exports = function(target, prefixes) {\n  var prefixIdx;\n  var prefix;\n  var testName;\n  var hostObject = this || (typeof window != 'undefined' ? window : undefined);\n\n  // if we have no host object, then abort\n  if (! hostObject) {\n    return;\n  }\n\n  // initialise to default prefixes\n  // (reverse order as we use a decrementing for loop)\n  prefixes = (prefixes || ['ms', 'o', 'moz', 'webkit']).concat('');\n\n  // iterate through the prefixes and return the class if found in global\n  for (prefixIdx = prefixes.length; prefixIdx--; ) {\n    prefix = prefixes[prefixIdx];\n\n    // construct the test class name\n    // if we have a prefix ensure the target has an uppercase first character\n    // such that a test for getUserMedia would result in a\n    // search for webkitGetUserMedia\n    testName = prefix + (prefix ?\n                            target.charAt(0).toUpperCase() + target.slice(1) :\n                            target);\n\n    if (typeof hostObject[testName] != 'undefined') {\n      // update the last used prefix\n      detect.browser = detect.browser || prefix.toLowerCase();\n\n      // return the host object member\n      return hostObject[target] = hostObject[testName];\n    }\n  }\n};\n\n// detect mozilla (yes, this feels dirty)\ndetect.moz = typeof navigator != 'undefined' && !!navigator.mozGetUserMedia;\n\n// set the browser and browser version\ndetect.browser = browser.name;\ndetect.browserVersion = detect.version = browser.version;\n",
    "var browsers = [\n  [ 'chrome', /Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/ ],\n  [ 'firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/ ],\n  [ 'opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/ ],\n  [ 'ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+)\\).*Gecko$/ ],\n  [ 'ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-6].0/ ],\n  [ 'ie', /MSIE\\s(7\\.0)/ ],\n  [ 'bb10', /BB10;\\sTouch.*Version\\/([0-9\\.]+)/ ],\n  [ 'android', /Android\\s([0-9\\.]+)/ ],\n  [ 'ios', /iPad\\;\\sCPU\\sOS\\s([0-9\\._]+)/ ],\n  [ 'ios',  /iPhone\\;\\sCPU\\siPhone\\sOS\\s([0-9\\._]+)/ ],\n  [ 'safari', /Safari\\/([0-9\\._]+)/ ]\n];\n\nvar match = browsers.map(match).filter(isMatch)[0];\nvar parts = match && match[3].split(/[._]/).slice(0,3);\n\nwhile (parts && parts.length < 3) {\n  parts.push('0');\n}\n\n// set the name and version\nexports.name = match && match[0];\nexports.version = parts && parts.join('.');\n\nfunction match(pair) {\n  return pair.concat(pair[1].exec(navigator.userAgent));\n}\n\nfunction isMatch(pair) {\n  return !!pair[2];\n}\n",
    "var detect = require('./detect');\nvar requiredFunctions = [\n  'init'\n];\n\nfunction isSupported(plugin) {\n  return plugin && typeof plugin.supported == 'function' && plugin.supported(detect);\n}\n\nfunction isValid(plugin) {\n  var supportedFunctions = requiredFunctions.filter(function(fn) {\n    return typeof plugin[fn] == 'function';\n  });\n\n  return supportedFunctions.length === requiredFunctions.length;\n}\n\nmodule.exports = function(plugins) {\n  return [].concat(plugins || []).filter(isSupported).filter(isValid)[0];\n}\n",
    "(function (process){\n/* jshint node: true */\n'use strict';\n\nvar rtc = require('rtc-tools');\nvar mbus = require('mbus');\nvar cleanup = require('rtc-tools/cleanup');\nvar debug = rtc.logger('rtc-quickconnect');\nvar defaults = require('cog/defaults');\nvar extend = require('cog/extend');\nvar getable = require('cog/getable');\nvar reTrailingSlash = /\\/$/;\n\n/**\n  # rtc-quickconnect\n\n  This is a high level helper module designed to help you get up\n  an running with WebRTC really, really quickly.  By using this module you\n  are trading off some flexibility, so if you need a more flexible\n  configuration you should drill down into lower level components of the\n  [rtc.io](http://www.rtc.io) suite.  In particular you should check out\n  [rtc](https://github.com/rtc-io/rtc).\n\n  ## Example Usage\n\n  In the simplest case you simply call quickconnect with a single string\n  argument which tells quickconnect which server to use for signaling:\n\n  <<< examples/simple.js\n\n  <<< docs/events.md\n\n  <<< docs/examples.md\n\n  ## Regarding Signalling and a Signalling Server\n\n  Signaling is an important part of setting up a WebRTC connection and for\n  our examples we use our own test instance of the\n  [rtc-switchboard](https://github.com/rtc-io/rtc-switchboard). For your\n  testing and development you are more than welcome to use this also, but\n  just be aware that we use this for our testing so it may go up and down\n  a little.  If you need something more stable, why not consider deploying\n  an instance of the switchboard yourself - it's pretty easy :)\n\n  ## Reference\n\n  ```\n  quickconnect(signalhost, opts?) => rtc-sigaller instance (+ helpers)\n  ```\n\n  ### Valid Quick Connect Options\n\n  The options provided to the `rtc-quickconnect` module function influence the\n  behaviour of some of the underlying components used from the rtc.io suite.\n\n  Listed below are some of the commonly used options:\n\n  - `ns` (default: '')\n\n    An optional namespace for your signalling room.  While quickconnect\n    will generate a unique hash for the room, this can be made to be more\n    unique by providing a namespace.  Using a namespace means two demos\n    that have generated the same hash but use a different namespace will be\n    in different rooms.\n\n  - `room` (default: null) _added 0.6_\n\n    Rather than use the internal hash generation\n    (plus optional namespace) for room name generation, simply use this room\n    name instead.  __NOTE:__ Use of the `room` option takes precendence over\n    `ns`.\n\n  - `debug` (default: false)\n\n  Write rtc.io suite debug output to the browser console.\n\n  - `expectedLocalStreams` (default: not specified) _added 3.0_\n\n    By providing a positive integer value for this option will mean that\n    the created quickconnect instance will wait until the specified number of\n    streams have been added to the quickconnect \"template\" before announcing\n    to the signaling server.\n\n  - `manualJoin` (default: `false`)\n\n    Set this value to `true` if you would prefer to call the `join` function\n    to connecting to the signalling server, rather than having that happen\n    automatically as soon as quickconnect is ready to.\n\n  #### Options for Peer Connection Creation\n\n  Options that are passed onto the\n  [rtc.createConnection](https://github.com/rtc-io/rtc#createconnectionopts-constraints)\n  function:\n\n  - `iceServers`\n\n  This provides a list of ice servers that can be used to help negotiate a\n  connection between peers.\n\n  #### Options for P2P negotiation\n\n  Under the hood, quickconnect uses the\n  [rtc/couple](https://github.com/rtc-io/rtc#rtccouple) logic, and the options\n  passed to quickconnect are also passed onto this function.\n\n**/\nmodule.exports = function(signalhost, opts) {\n  var hash = typeof location != 'undefined' && location.hash.slice(1);\n  var signaller = require('rtc-signaller')(signalhost, opts);\n\n  // init configurable vars\n  var ns = (opts || {}).ns || '';\n  var room = (opts || {}).room;\n  var debugging = (opts || {}).debug;\n  var allowJoin = !(opts || {}).manualJoin;\n  var profile = {};\n  var announced = false;\n\n  // collect the local streams\n  var localStreams = [];\n\n  // create the calls map\n  var calls = signaller.calls = getable({});\n\n  // create the known data channels registry\n  var channels = {};\n\n  // save the plugins passed to the signaller\n  var plugins = signaller.plugins = (opts || {}).plugins || [];\n\n  // check how many local streams have been expected (default: 0)\n  var expectedLocalStreams = parseInt((opts || {}).expectedLocalStreams, 10) || 0;\n  var announceTimer = 0;\n\n  function callCreate(id, pc, data) {\n    calls.set(id, {\n      active: false,\n      pc: pc,\n      channels: getable({}),\n      data: data,\n      streams: []\n    });\n  }\n\n  function callEnd(id) {\n    var call = calls.get(id);\n\n    // if we have no data, then do nothing\n    if (! call) {\n      return;\n    }\n\n    debug('ending call to: ' + id);\n\n    // if we have no data, then return\n    call.channels.keys().forEach(function(label) {\n      var channel = call.channels.get(label);\n      var args = [id, channel, label];\n\n      // emit the plain channel:closed event\n      signaller.apply(signaller, ['channel:closed'].concat(args));\n\n      // emit the labelled version of the event\n      signaller.apply(signaller, ['channel:closed:' + label].concat(args));\n\n      // decouple the events\n      channel.onopen = null;\n    });\n\n    // trigger stream:removed events for each of the remotestreams in the pc\n    call.streams.forEach(function(stream) {\n      signaller('stream:removed', id, stream);\n    });\n\n    // delete the call data\n    calls.delete(id);\n\n    // trigger the call:ended event\n    signaller('call:ended', id, call.pc);\n\n    // ensure the peer connection is properly cleaned up\n    cleanup(call.pc);\n  }\n\n  function callStart(id, pc, data) {\n    var call = calls.get(id);\n    var streams = [].concat(pc.getRemoteStreams());\n\n    // flag the call as active\n    call.active = true;\n    call.streams = [].concat(pc.getRemoteStreams());\n\n    pc.onaddstream = createStreamAddHandler(id);\n    pc.onremovestream = createStreamRemoveHandler(id);\n\n    debug(signaller.id + ' - ' + id + ' call start: ' + streams.length + ' streams');\n    signaller('call:started', id, pc, data);\n\n    // examine the existing remote streams after a short delay\n    process.nextTick(function() {\n      // iterate through any remote streams\n      streams.forEach(receiveRemoteStream(id));\n    });\n  }\n\n  function checkReadyToAnnounce() {\n    clearTimeout(announceTimer);\n    if (! allowJoin) {\n      return;\n    }\n\n    // if we are waiting for a set number of streams, then wait until we have\n    // the required number\n    if (expectedLocalStreams && localStreams.length < expectedLocalStreams) {\n      return;\n    }\n\n    // announce ourselves to our new friend\n    announceTimer = setTimeout(function() {\n      var data = extend({}, profile, { room: room });\n\n      // announce and emit the local announce event\n      signaller.announce(data);\n      announced = true;\n    }, 0);\n  }\n\n  function createStreamAddHandler(id) {\n    return function(evt) {\n      debug('peer ' + id + ' added stream');\n      updateRemoteStreams(id);\n      receiveRemoteStream(id)(evt.stream);\n    }\n  }\n\n  function createStreamRemoveHandler(id) {\n    return function(evt) {\n      debug('peer ' + id + ' removed stream');\n      updateRemoteStreams(id);\n      signaller('stream:removed', id, evt.stream);\n    };\n  }\n\n  function getActiveCall(peerId) {\n    var call = calls.get(peerId);\n\n    if (! call) {\n      throw new Error('No active call for peer: ' + peerId);\n    }\n\n    return call;\n  }\n\n  function gotPeerChannel(channel, pc, data) {\n    var channelMonitor;\n\n    function channelReady() {\n      var call = calls.get(data.id);\n      var args = [ data.id, channel, data, pc ];\n\n      // decouple the channel.onopen listener\n      debug('reporting channel \"' + channel.label + '\" ready, have call: ' + (!!call));\n      clearInterval(channelMonitor);\n      channel.onopen = null;\n\n      // save the channel\n      if (call) {\n        call.channels.set(channel.label, channel);\n      }\n\n      // trigger the %channel.label%:open event\n      debug('triggering channel:opened events for channel: ' + channel.label);\n\n      // emit the plain channel:opened event\n      signaller.apply(signaller, ['channel:opened'].concat(args));\n\n      // emit the channel:opened:%label% eve\n      signaller.apply(\n        signaller,\n        ['channel:opened:' + channel.label].concat(args)\n      );\n    }\n\n    debug('channel ' + channel.label + ' discovered for peer: ' + data.id);\n    if (channel.readyState === 'open') {\n      return channelReady();\n    }\n\n    debug('channel not ready, current state = ' + channel.readyState);\n    channel.onopen = channelReady;\n\n    // monitor the channel open (don't trust the channel open event just yet)\n    channelMonitor = setInterval(function() {\n      debug('checking channel state, current state = ' + channel.readyState);\n      if (channel.readyState === 'open') {\n        channelReady();\n      }\n    }, 500);\n  }\n\n  function handleLocalAnnounce(data) {\n    // if we send an announce with an updated room then update our local room name\n    if (data && typeof data.room != 'undefined') {\n      room = data.room;\n    }\n  }\n\n  function handlePeerAnnounce(data) {\n    var pc;\n    var monitor;\n\n    // if the room is not a match, abort\n    if (data.room !== room) {\n      return;\n    }\n\n    // create a peer connection\n    pc = rtc.createConnection(opts, (opts || {}).constraints);\n    signaller('peer:connect', data.id, pc, data);\n\n    // add this connection to the calls list\n    callCreate(data.id, pc, data);\n\n    // add the local streams\n    localStreams.forEach(function(stream, idx) {\n      pc.addStream(stream);\n    });\n\n    // add the data channels\n    // do this differently based on whether the connection is a\n    // master or a slave connection\n    if (signaller.isMaster(data.id)) {\n      debug('is master, creating data channels: ', Object.keys(channels));\n\n      // create the channels\n      Object.keys(channels).forEach(function(label) {\n       gotPeerChannel(pc.createDataChannel(label, channels[label]), pc, data);\n      });\n    }\n    else {\n      pc.ondatachannel = function(evt) {\n        var channel = evt && evt.channel;\n\n        // if we have no channel, abort\n        if (! channel) {\n          return;\n        }\n\n        if (channels[channel.label] !== undefined) {\n          gotPeerChannel(channel, pc, data);\n        }\n      };\n    }\n\n    // couple the connections\n    debug('coupling ' + signaller.id + ' to ' + data.id);\n    monitor = rtc.couple(pc, data.id, signaller, extend({}, opts, {\n      logger: mbus('pc.' + data.id, signaller)\n    }));\n\n    signaller('peer:couple', data.id, pc, data, monitor);\n\n    // once active, trigger the peer connect event\n    monitor.once('connected', callStart.bind(null, data.id, pc, data))\n    monitor.once('closed', callEnd.bind(null, data.id));\n\n    // if we are the master connnection, create the offer\n    // NOTE: this only really for the sake of politeness, as rtc couple\n    // implementation handles the slave attempting to create an offer\n    if (signaller.isMaster(data.id)) {\n      monitor.createOffer();\n    }\n  }\n\n  function handlePeerFilter(evt) {\n    // only connect with the peer if we are ready\n    evt.allow = evt.allow && (localStreams.length >= expectedLocalStreams);\n  }\n\n  function handlePeerUpdate(data) {\n    var id = data && data.id;\n    var activeCall = id && calls.get(id);\n\n    // if we have received an update for a peer that has no active calls,\n    // then pass this onto the announce handler\n    if (id && (! activeCall)) {\n      debug('received peer update from peer ' + id + ', no active calls');\n      return handlePeerAnnounce(data);\n    }\n  }\n\n  function receiveRemoteStream(id) {\n    var call = calls.get(id);\n\n    return function(stream) {\n      signaller('stream:added', id, stream, call && call.data);\n    };\n  }\n\n  function updateRemoteStreams(id) {\n    var call = calls.get(id);\n\n    if (call && call.pc) {\n      call.streams = [].concat(call.pc.getRemoteStreams());\n    }\n  }\n\n  // if the room is not defined, then generate the room name\n  if (! room) {\n    // if the hash is not assigned, then create a random hash value\n    if (! hash) {\n      hash = location.hash = '' + (Math.pow(2, 53) * Math.random());\n    }\n\n    room = ns + '#' + hash;\n  }\n\n  if (debugging) {\n    rtc.logger.enable.apply(rtc.logger, Array.isArray(debug) ? debugging : ['*']);\n  }\n\n  signaller.on('peer:announce', handlePeerAnnounce);\n  signaller.on('peer:update', handlePeerUpdate);\n  signaller.on('peer:leave', callEnd);\n\n  /**\n    ### Quickconnect Broadcast and Data Channel Helper Functions\n\n    The following are functions that are patched into the `rtc-signaller`\n    instance that make working with and creating functional WebRTC applications\n    a lot simpler.\n\n  **/\n\n  /**\n    #### addStream\n\n    ```\n    addStream(stream:MediaStream) => qc\n    ```\n\n    Add the stream to active calls and also save the stream so that it\n    can be added to future calls.\n\n  **/\n  signaller.broadcast = signaller.addStream = function(stream) {\n    localStreams.push(stream);\n\n    // if we have any active calls, then add the stream\n    calls.values().forEach(function(data) {\n      data.pc.addStream(stream);\n    });\n\n    checkReadyToAnnounce();\n    return signaller;\n  };\n\n  /**\n    #### endCalls()\n\n    The `endCalls` function terminates all the active calls that have been\n    created in this quickconnect instance.  Calling `endCalls` does not\n    kill the connection with the signalling server.\n\n  **/\n  signaller.endCalls = function() {\n    calls.keys().forEach(callEnd);\n  };\n\n  /**\n    #### close()\n\n    The `close` function provides a convenient way of closing all associated\n    peer connections.  This function simply uses the `endCalls` function and\n    the underlying `leave` function of the signaller to do a \"full cleanup\"\n    of all connections.\n  **/\n  signaller.close = function() {\n    signaller.endCalls();\n    signaller.leave();\n  };\n\n  /**\n    #### createDataChannel(label, config)\n\n    Request that a data channel with the specified `label` is created on\n    the peer connection.  When the data channel is open and available, an\n    event will be triggered using the label of the data channel.\n\n    For example, if a new data channel was requested using the following\n    call:\n\n    ```js\n    var qc = quickconnect('http://rtc.io/switchboard').createDataChannel('test');\n    ```\n\n    Then when the data channel is ready for use, a `test:open` event would\n    be emitted by `qc`.\n\n  **/\n  signaller.createDataChannel = function(label, opts) {\n    // create a channel on all existing calls\n    calls.keys().forEach(function(peerId) {\n      var call = calls.get(peerId);\n      var dc;\n\n      // if we are the master connection, create the data channel\n      if (call && call.pc && signaller.isMaster(peerId)) {\n        dc = call.pc.createDataChannel(label, opts);\n        gotPeerChannel(dc, call.pc, call.data);\n      }\n    });\n\n    // save the data channel opts in the local channels dictionary\n    channels[label] = opts || null;\n\n    return signaller;\n  };\n\n  /**\n    #### join()\n\n    The `join` function is used when `manualJoin` is set to true when creating\n    a quickconnect instance.  Call the `join` function once you are ready to\n    join the signalling server and initiate connections with other people.\n\n  **/\n  signaller.join = function() {\n    allowJoin = true;\n    checkReadyToAnnounce();\n  };\n\n  /**\n    #### reactive()\n\n    Flag that this session will be a reactive connection.\n\n  **/\n  signaller.reactive = function() {\n    // add the reactive flag\n    opts = opts || {};\n    opts.reactive = true;\n\n    // chain\n    return signaller;\n  };\n\n  /**\n    #### removeStream\n\n    ```\n    removeStream(stream:MediaStream)\n    ```\n\n    Remove the specified stream from both the local streams that are to\n    be connected to new peers, and also from any active calls.\n\n  **/\n  signaller.removeStream = function(stream) {\n    var localIndex = localStreams.indexOf(stream);\n\n    // remove the stream from any active calls\n    calls.values().forEach(function(call) {\n      call.pc.removeStream(stream);\n    });\n\n    // remove the stream from the localStreams array\n    if (localIndex >= 0) {\n      localStreams.splice(localIndex, 1);\n    }\n\n    return signaller;\n  };\n\n  /**\n    #### requestChannel\n\n    ```\n    requestChannel(targetId, label, callback)\n    ```\n\n    This is a function that can be used to respond to remote peers supplying\n    a data channel as part of their configuration.  As per the `receiveStream`\n    function this function will either fire the callback immediately if the\n    channel is already available, or once the channel has been discovered on\n    the call.\n\n  **/\n  signaller.requestChannel = function(targetId, label, callback) {\n    var call = getActiveCall(targetId);\n    var channel = call && call.channels.get(label);\n\n    // if we have then channel trigger the callback immediately\n    if (channel) {\n      callback(null, channel);\n      return signaller;\n    }\n\n    // if not, wait for it\n    signaller.once('channel:opened:' + label, function(id, dc) {\n      callback(null, dc);\n    });\n\n    return signaller;\n  };\n\n  /**\n    #### requestStream\n\n    ```\n    requestStream(targetId, idx, callback)\n    ```\n\n    Used to request a remote stream from a quickconnect instance. If the\n    stream is already available in the calls remote streams, then the callback\n    will be triggered immediately, otherwise this function will monitor\n    `stream:added` events and wait for a match.\n\n    In the case that an unknown target is requested, then an exception will\n    be thrown.\n  **/\n  signaller.requestStream = function(targetId, idx, callback) {\n    var call = getActiveCall(targetId);\n    var stream;\n\n    function waitForStream(peerId) {\n      if (peerId !== targetId) {\n        return;\n      }\n\n      // get the stream\n      stream = call.pc.getRemoteStreams()[idx];\n\n      // if we have the stream, then remove the listener and trigger the cb\n      if (stream) {\n        signaller.removeListener('stream:added', waitForStream);\n        callback(null, stream);\n      }\n    }\n\n    // look for the stream in the remote streams of the call\n    stream = call.pc.getRemoteStreams()[idx];\n\n    // if we found the stream then trigger the callback\n    if (stream) {\n      callback(null, stream);\n      return signaller;\n    }\n\n    // otherwise wait for the stream\n    signaller.on('stream:added', waitForStream);\n    return signaller;\n  };\n\n  /**\n    #### profile(data)\n\n    Update the profile data with the attached information, so when\n    the signaller announces it includes this data in addition to any\n    room and id information.\n\n  **/\n  signaller.profile = function(data) {\n    extend(profile, data);\n\n    // if we have already announced, then reannounce our profile to provide\n    // others a `peer:update` event\n    if (announced) {\n      signaller.announce(profile);\n    }\n\n    return signaller;\n  };\n\n  /**\n    #### waitForCall\n\n    ```\n    waitForCall(targetId, callback)\n    ```\n\n    Wait for a call from the specified targetId.  If the call is already\n    active the callback will be fired immediately, otherwise we will wait\n    for a `call:started` event that matches the requested `targetId`\n\n  **/\n  signaller.waitForCall = function(targetId, callback) {\n    var call = calls.get(targetId);\n\n    if (call && call.active) {\n      callback(null, call.pc);\n      return signaller;\n    }\n\n    signaller.on('call:started', function handleNewCall(id) {\n      if (id === targetId) {\n        signaller.removeListener('call:started', handleNewCall);\n        callback(null, calls.get(id).pc);\n      }\n    });\n  };\n\n  // if we have an expected number of local streams, then use a filter to\n  // check if we should respond\n  if (expectedLocalStreams) {\n    signaller.on('peer:filter', handlePeerFilter);\n  }\n\n  // respond to local announce messages\n  signaller.on('local:announce', handleLocalAnnounce);\n\n  // check to see if we are ready to announce\n  checkReadyToAnnounce();\n\n  // pass the signaller on\n  return signaller;\n};\n\n}).call(this,require('_process'))",
    "var createTrie = require('array-trie');\nvar reDelim = /[\\.\\:]/;\n\n/**\n  # mbus\n\n  If Node's EventEmitter and Eve were to have a child, it might look something like this.\n  No wildcard support at this stage though...\n\n  ## Example Usage\n\n  <<< docs/usage.md\n\n  ## Reference\n\n  ### `mbus(namespace?, parent?, scope?)`\n\n  Create a new message bus with `namespace` inheriting from the `parent`\n  mbus instance.  If events from this message bus should be triggered with\n  a specific `this` scope, then specify it using the `scope` argument.\n\n**/\n\nvar createBus = module.exports = function(namespace, parent, scope) {\n  var registry = createTrie();\n  var feeds = [];\n\n  function bus(name) {\n    var args = [].slice.call(arguments, 1);\n    var parts = getNameParts(name);\n    var delimited = parts.join('.');\n    var handlers = registry.get(parts) || [];\n    var results;\n\n    // send through the feeds\n    feeds.forEach(function(feed) {\n      feed({ name: delimited, args: args });\n    });\n\n    // run the registered handlers\n    results = [].concat(handlers).map(function(handler) {\n      return handler.apply(scope || this, args);\n    });\n\n    // run the parent handlers\n    if (bus.parent) {\n      results = results.concat(\n        bus.parent.apply(scope || this, [namespace.concat(parts)].concat(args))\n      );\n    }\n\n    return results;\n  }\n\n  /**\n    ### `mbus#clear()`\n\n    Reset the handler registry, which essential deregisters all event listeners.\n\n    _Alias:_ `removeAllListeners`\n  **/\n  function clear(name) {\n    // if we have a name, reset handlers for that handler\n    if (name) {\n      registry.set(getNameParts(name), []);\n    }\n    // otherwise, reset the entire handler registry\n    else {\n      registry = createTrie();\n    }\n  }\n\n  /**\n    ### `mbus#feed(handler)`\n\n    Attach a handler function that will see all events that are sent through\n    this bus in an \"object stream\" format that matches the following format:\n\n    ```\n    { name: 'event.name', args: [ 'event', 'args' ] }\n    ```\n\n    The feed function returns a function that can be called to stop the feed\n    sending data.\n\n  **/\n  function feed(handler) {\n    function stop() {\n      feeds.splice(feeds.indexOf(handler), 1);\n    }\n\n    feeds.push(handler);\n    return stop;\n  }\n\n  function getNameParts(name) {\n    return Array.isArray(name) ? name : name.split(reDelim);\n  }\n\n  /**\n    ### `mbus#off(name, handler)`\n\n    Deregister an event handler.\n  **/\n  function off(name, handler) {\n    var handlers = registry.get(getNameParts(name));\n    var idx = handlers ? handlers.indexOf(handler) : -1;\n\n    if (idx >= 0) {\n      handlers.splice(idx, 1);\n    }\n  }\n\n  /**\n    ### `mbus#on(name, handler)`\n\n    Register an event handler for the event `name`.\n\n  **/\n  function on(name, handler) {\n    var parts = getNameParts(name);\n    var handlers = registry.get(parts);\n\n    if (handlers) {\n      handlers.push(handler);\n    }\n    else {\n      registry.set(parts, [ handler ]);\n    }\n\n    return bus;\n  }\n\n\n  /**\n    ### `mbus#once(name, handler)`\n\n    Register an event handler for the event `name` that will only\n    trigger once (i.e. the handler will be deregistered immediately after\n    being triggered the first time).\n\n  **/\n  function once(name, handler) {\n    return on(name, function handleEvent() {\n      var result = handler.apply(this, arguments);\n      bus.off(name, handleEvent);\n\n      return result;\n    });\n  }\n\n  if (typeof namespace == 'function') {\n    parent = namespace;\n    namespace = '';\n  }\n\n  namespace = (namespace && namespace.split(reDelim)) || [];\n\n  bus.clear = bus.removeAllListeners = clear;\n  bus.feed = feed;\n  bus.on = bus.addListener = on;\n  bus.once = once;\n  bus.off = bus.removeListener = off;\n  bus.parent = parent || (namespace && namespace.length > 0 && createBus());\n\n  return bus;\n};\n",
    "\"use strict\"\n\nfunction compileSearch(funcName, predicate, reversed, extraArgs, useNdarray, earlyOut) {\n  var code = [\n    \"function \", funcName, \"(a,l,h,\", extraArgs.join(\",\"),  \"){\",\nearlyOut ? \"\" : \"var i=\", (reversed ? \"l-1\" : \"h+1\"),\n\";while(l<=h){\\\nvar m=(l+h)>>>1,x=a\", useNdarray ? \".get(m)\" : \"[m]\"]\n  if(earlyOut) {\n    if(predicate.indexOf(\"c\") < 0) {\n      code.push(\";if(x===y){return m}else if(x<=y){\")\n    } else {\n      code.push(\";var p=c(x,y);if(p===0){return m}else if(p<=0){\")\n    }\n  } else {\n    code.push(\";if(\", predicate, \"){i=m;\")\n  }\n  if(reversed) {\n    code.push(\"l=m+1}else{h=m-1}\")\n  } else {\n    code.push(\"h=m-1}else{l=m+1}\")\n  }\n  code.push(\"}\")\n  if(earlyOut) {\n    code.push(\"return -1};\")\n  } else {\n    code.push(\"return i};\")\n  }\n  return code.join(\"\")\n}\n\nfunction compileBoundsSearch(predicate, reversed, suffix, earlyOut) {\n  var result = new Function([\n  compileSearch(\"A\", \"x\" + predicate + \"y\", reversed, [\"y\"], false, earlyOut),\n  compileSearch(\"B\", \"x\" + predicate + \"y\", reversed, [\"y\"], true, earlyOut),\n  compileSearch(\"P\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], false, earlyOut),\n  compileSearch(\"Q\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], true, earlyOut),\n\"function dispatchBsearch\", suffix, \"(a,y,c,l,h){\\\nif(a.shape){\\\nif(typeof(c)==='function'){\\\nreturn Q(a,(l===undefined)?0:l|0,(h===undefined)?a.shape[0]-1:h|0,y,c)\\\n}else{\\\nreturn B(a,(c===undefined)?0:c|0,(l===undefined)?a.shape[0]-1:l|0,y)\\\n}}else{\\\nif(typeof(c)==='function'){\\\nreturn P(a,(l===undefined)?0:l|0,(h===undefined)?a.length-1:h|0,y,c)\\\n}else{\\\nreturn A(a,(c===undefined)?0:c|0,(l===undefined)?a.length-1:l|0,y)\\\n}}}\\\nreturn dispatchBsearch\", suffix].join(\"\"))\n  return result()\n}\n\nmodule.exports = {\n  ge: compileBoundsSearch(\">=\", false, \"GE\"),\n  gt: compileBoundsSearch(\">\", false, \"GT\"),\n  lt: compileBoundsSearch(\"<\", true, \"LT\"),\n  le: compileBoundsSearch(\"<=\", true, \"LE\"),\n  eq: compileBoundsSearch(\"-\", true, \"EQ\", true)\n}\n",
    "\"use strict\"\n\nvar bounds = require(\"binary-search-bounds\")\n\nmodule.exports = createTrie\n\nfunction Trie(symbols, children, value) {\n  this.symbols = symbols\n  this.children = children\n  this.value = value\n}\n\nvar proto = Trie.prototype\n\nproto.set = function(s, value) {\n  if(s.shape) {\n    var v = this\n    var n = s.shape[0]\n    for(var i=0; i<n; ++i) {\n      var c = s.get(i)\n      var j = bounds.ge(v.symbols, c)\n      if(j < v.symbols.length && v.symbols[j] === c) {\n        v = v.children[j]\n      } else {\n        var l = new Trie([], [], value)\n        for(var k=n-1; k>i; --k) {\n          l = new Trie([s.get(k)], [l])\n        }\n        v.symbols.splice(j, 0, c)\n        v.children.splice(j, 0, l)\n        return value\n      }\n    }\n    return v.value = value\n  } else {\n    var v = this\n    var n = s.length\n    for(var i=0; i<n; ++i) {\n      var c = s[i]\n      var j = bounds.ge(v.symbols, c)\n      if(j < v.symbols.length && v.symbols[j] === c) {\n        v = v.children[j]\n      } else {\n        var l = new Trie([], [], value)\n        for(var k=n-1; k>i; --k) {\n          l = new Trie([s[k]], [l])\n        }\n        v.symbols.splice(j, 0, c)\n        v.children.splice(j, 0, l)\n        return value\n      }\n    }\n    return v.value = value\n  }\n}\n\nproto.get = function(s) {\n  if(s.shape) {\n    var v = this\n    var n = s.shape[0]\n    for(var i=0; i<n; ++i) {\n      var c = s.get(i)\n      var j = bounds.eq(v.symbols, c)\n      if(j < 0) {\n        return\n      }\n      v = v.children[j]\n    }\n    return v.value\n  } else {\n    var v = this\n    var n = s.length\n    for(var i=0; i<n; ++i) {\n      var c = s[i]\n      var j = bounds.eq(v.symbols, c)\n      if(j < 0) {\n        return\n      }\n      v = v.children[j]\n    }\n    return v.value\n  }\n}\n\nfunction createTrie() {\n  return new Trie([],[])\n}",
    "var extend = require('cog/extend');\n\nmodule.exports = function(messenger, opts) {\n  return require('./signaller.js')(messenger, extend({\n    connect: require('./primus-loader')\n  }, opts));\n};\n",
    "module.exports = {\n  // messenger events\n  dataEvent: 'data',\n  openEvent: 'open',\n  closeEvent: 'close',\n  errorEvent: 'error',\n\n  // messenger functions\n  writeMethod: 'write',\n  closeMethod: 'close',\n\n  // leave timeout (ms)\n  leaveTimeout: 3000\n};\n",
    "/* jshint node: true */\n'use strict';\n\nvar debug = require('cog/logger')('rtc-signaller');\nvar extend = require('cog/extend');\nvar roles = ['a', 'b'];\n\n/**\n  #### announce\n\n  ```\n  /announce|%metadata%|{\"id\": \"...\", ... }\n  ```\n\n  When an announce message is received by the signaller, the attached\n  object data is decoded and the signaller emits an `announce` message.\n\n**/\nmodule.exports = function(signaller) {\n\n  function copyData(target, source) {\n    if (target && source) {\n      for (var key in source) {\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function dataAllowed(data) {\n    var evt = {\n      data: data,\n      allow: true\n    };\n\n    signaller('peer:filter', evt);\n\n    return evt.allow;\n  }\n\n  return function(args, messageType, srcData, srcState, isDM) {\n    var data = args[0];\n    var peer;\n\n    debug('announce handler invoked, received data: ', data);\n\n    // if we have valid data then process\n    if (data && data.id && data.id !== signaller.id) {\n      if (! dataAllowed(data)) {\n        return;\n      }\n      // check to see if this is a known peer\n      peer = signaller.peers.get(data.id);\n\n      // trigger the peer connected event to flag that we know about a\n      // peer connection. The peer has passed the \"filter\" check but may\n      // be announced / updated depending on previous connection status\n      signaller('peer:connected', data.id, data);\n\n      // if the peer is existing, then update the data\n      if (peer && (! peer.inactive)) {\n        debug('signaller: ' + signaller.id + ' received update, data: ', data);\n\n        // update the data\n        copyData(peer.data, data);\n\n        // trigger the peer update event\n        return signaller('peer:update', data, srcData);\n      }\n\n      // create a new peer\n      peer = {\n        id: data.id,\n\n        // initialise the local role index\n        roleIdx: [data.id, signaller.id].sort().indexOf(data.id),\n\n        // initialise the peer data\n        data: {}\n      };\n\n      // initialise the peer data\n      copyData(peer.data, data);\n\n      // reset inactivity state\n      clearTimeout(peer.leaveTimer);\n      peer.inactive = false;\n\n      // set the peer data\n      signaller.peers.set(data.id, peer);\n\n      // if this is an initial announce message (no vector clock attached)\n      // then send a announce reply\n      if (signaller.autoreply && (! isDM)) {\n        signaller\n          .to(data.id)\n          .send('/announce', signaller.attributes);\n      }\n\n      // emit a new peer announce event\n      return signaller('peer:announce', data, peer);\n    }\n  };\n};\n",
    "/* jshint node: true */\n'use strict';\n\n/**\n  ### signaller message handlers\n\n**/\n\nmodule.exports = function(signaller, opts) {\n  return {\n    announce: require('./announce')(signaller, opts),\n    leave: require('./leave')(signaller, opts)\n  };\n};",
    "/* jshint node: true */\n'use strict';\n\n/**\n  #### leave\n\n  ```\n  /leave|{\"id\":\"...\"}\n  ```\n\n  When a leave message is received from a peer, we check to see if that is\n  a peer that we are managing state information for and if we are then the\n  peer state is removed.\n\n**/\nmodule.exports = function(signaller, opts) {\n  return function(args) {\n    var data = args[0];\n    var peer = signaller.peers.get(data && data.id);\n\n    if (peer) {\n      // start the inactivity timer\n      peer.leaveTimer = setTimeout(function() {\n        peer.inactive = true;\n        signaller('peer:leave', data.id, peer);\n      }, opts.leaveTimeout);\n    }\n\n    // emit the event\n    signaller('peer:disconnected', data.id, peer);\n  };\n};\n",
    "/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n * \n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\n/*global window, navigator, document, require, process, module */\n(function (app) {\n  'use strict';\n  var namespace = 'cuid',\n    c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize),\n\n    pad = function pad(num, size) {\n      var s = \"000000000\" + num;\n      return s.substr(s.length-size);\n    },\n\n    randomBlock = function randomBlock() {\n      return pad((Math.random() *\n            discreteValues << 0)\n            .toString(base), blockSize);\n    },\n\n    safeCounter = function () {\n      c = (c < discreteValues) ? c : 0;\n      c++; // this is not subliminal\n      return c - 1;\n    },\n\n    api = function cuid() {\n      // Starting with a lowercase letter makes\n      // it HTML element ID friendly.\n      var letter = 'c', // hard-coded allows for sequential access\n\n        // timestamp\n        // warning: this exposes the exact date and time\n        // that the uid was created.\n        timestamp = (new Date().getTime()).toString(base),\n\n        // Prevent same-machine collisions.\n        counter,\n\n        // A few chars to generate distinct ids for different\n        // clients (so different computers are far less\n        // likely to generate the same id)\n        fingerprint = api.fingerprint(),\n\n        // Grab some more chars from Math.random()\n        random = randomBlock() + randomBlock();\n\n        counter = pad(safeCounter().toString(base), blockSize);\n\n      return  (letter + timestamp + counter + fingerprint + random);\n    };\n\n  api.slug = function slug() {\n    var date = new Date().getTime().toString(36),\n      counter,\n      print = api.fingerprint().slice(0,1) +\n        api.fingerprint().slice(-1),\n      random = randomBlock().slice(-2);\n\n      counter = safeCounter().toString(36).slice(-4);\n\n    return date.slice(-2) + \n      counter + print + random;\n  };\n\n  api.globalCount = function globalCount() {\n    // We want to cache the results of this\n    var cache = (function calc() {\n        var i,\n          count = 0;\n\n        for (i in window) {\n          count++;\n        }\n\n        return count;\n      }());\n\n    api.globalCount = function () { return cache; };\n    return cache;\n  };\n\n  api.fingerprint = function browserPrint() {\n    return pad((navigator.mimeTypes.length +\n      navigator.userAgent.length).toString(36) +\n      api.globalCount().toString(36), 4);\n  };\n\n  // don't change anything from here down.\n  if (app.register) {\n    app.register(namespace, api);\n  } else if (typeof module !== 'undefined') {\n    module.exports = api;\n  } else {\n    app[namespace] = api;\n  }\n\n}(this.applitude || this));\n",
    "/* jshint node: true */\n'use strict';\n\nvar reVariable = /\\{\\{\\s*([^\\}]+?)\\s*\\}\\}/;\nvar mods = require('./mods');\n\n/**\n  # formatter\n\n  This is a simple library designed to do one thing and one thing only -\n  replace variables in strings with variable values.  It is built in such a\n  way that the formatter strings are parsed and you are provided with a\n  function than can efficiently be called to provide the custom output.\n\n  ## Example Usage\n\n  <<< examples/likefood.js\n\n  __NOTE__: Formatter is not designed to be a templating library and if\n  you are already using something like Handlebars or\n  [hogan](https://github.com/twitter/hogan.js) in your library or application\n  stack consider using them instead.\n\n  ## Using named variables\n\n  In the examples above we saw how the formatter can be used to replace\n  function arguments in a formatter string.  We can also set up a formatter\n  to use particular key values from an input string instead if that is more\n  suitable:\n\n  <<< examples/likefood-named.js\n\n  ## Nested Property Values\n\n  Since version `0.1.0` you can also access nested property values, as you\n  can with templates like handlebars.\n\n  ## Partial Execution\n\n  Since version `0.3.x` formatter also supports partial execution when using\n  indexed arguments (e.g. `{{ 0 }}`, `{{ 1 }}`, etc).  For example:\n\n  <<< examples/partial.js\n\n  In the case above, the original formatter function returned by `formatter`\n  did not receive enough values to resolve all the required variables.  As\n  such it returned a function ready to accept the remaining values.\n\n  Once all values have been received the output will be generated.\n\n  ## Performance\n\n  I've done some\n  [performance benchmarks](http://jsperf.com/formatter-performance) and\n  formatter is faster than handlebars, but that isn't surprising as it is far\n  simpler and doesn't have the smarts of HBS.  The test is really there to\n  ensure that I didn't do anything too silly...\n\n  Additionally, it should be noted that using formatter is 100% slower than\n  concatenating strings, so don't use it where performance is critical. \n  Do use it where not repeating yourself is.\n**/\n\nvar formatter = module.exports = function(format, opts) {\n  // extract the matches from the string\n  var parts = [];\n  var output = [];\n  var chunk;\n  var varname;\n  var varParts;\n  var match = reVariable.exec(format);\n  var isNumeric;\n  var outputIdx = 0;\n  var ignoreNumeric = (opts || {}).ignoreNumeric;\n\n  while (match) {\n    // get the prematch chunk\n    chunk = format.slice(0, match.index);\n    \n    // if we have a valid chunk, add it to the parts\n    if (chunk) {\n      output[outputIdx++] = chunk;\n    }\n    \n    varParts = match[1].split(/\\s*\\|\\s*/);\n    match[1] = varParts[0];\n    \n    // extract the varname\n    varname = parseInt(match[1], 10);\n    isNumeric = !isNaN(varname);\n\n    // if this is a numeric replacement expression, and we are ignoring\n    // those expressions then pass it through to the output\n    if (ignoreNumeric && isNumeric) {\n      output[outputIdx++] = match[0];\n    }\n    // otherwise, handle normally\n    else {\n      // extract the expression and add it as a function\n      parts[parts.length] = {\n        idx: (outputIdx++),\n        numeric: isNumeric,\n        varname: isNumeric ? varname : match[1],\n        modifiers: varParts.length > 1 ? createModifiers(varParts.slice(1)) : []\n      };\n    }\n\n    // remove this matched chunk and replacer from the string\n    format = format.slice(match.index + match[0].length);\n\n    // check for the next match\n    match = reVariable.exec(format);\n  }\n  \n  // if we still have some of the format string remaining, add it to the list\n  if (format) {\n    output[outputIdx++] = format;\n  }\n\n  return collect(parts, output);\n};\n\nformatter.error = function(message) {\n  // create the format\n  var format = formatter(message);\n  \n  return function(err) {\n    var output;\n    \n    // if no error has been supplied, then pass it straight through\n    if (! err) {\n      return;\n    }\n\n    output = new Error(\n      format.apply(null, Array.prototype.slice.call(arguments, 1)));\n\n    output._original = err;\n\n    // return the new error\n    return output;\n  };\n};\n\nfunction collect(parts, resolved, indexShift) {\n  // default optionals\n  indexShift = indexShift || 0;\n\n  return function() {\n    var output = [].concat(resolved);\n    var unresolved;\n    var ii;\n    var part;\n    var partIdx;\n    var propNames;\n    var val;\n    var numericResolved = [];\n\n    // find the unresolved parts\n    unresolved = parts.filter(function(part) {\n      return typeof output[part.idx] == 'undefined';\n    });\n\n    // initialise the counter\n    ii = unresolved.length;\n\n    // iterate through the unresolved parts and attempt to resolve the value\n    for (; ii--; ) {\n      part = unresolved[ii];\n\n      if (typeof part == 'object') {\n        // if this is a numeric part, this is a simple index lookup\n        if (part.numeric) {\n          partIdx = part.varname - indexShift;\n          if (arguments.length > partIdx) {\n            output[part.idx] = arguments[partIdx];\n            if (numericResolved.indexOf(part.varname) < 0) {\n              numericResolved[numericResolved.length] = part.varname;\n            }\n          }\n        }\n        // otherwise, we are doing a recursive property search\n        else if (arguments.length > 0) {\n          propNames = (part.varname || '').split('.');\n\n          // initialise the output from the last valid argument\n          output[part.idx] = (arguments[arguments.length - 1] || {});\n          while (output[part.idx] && propNames.length > 0) {\n            val = output[part.idx][propNames.shift()];\n            output[part.idx] = typeof val != 'undefined' ? val : '';\n          }\n        }\n\n        // if the output was resolved, then apply the modifier\n        if (typeof output[part.idx] != 'undefined' && part.modifiers) {\n          output[part.idx] = applyModifiers(part.modifiers, output[part.idx]);\n        }\n      }\n    }\n\n    // reasses unresolved (only caring about numeric parts)\n    unresolved = parts.filter(function(part) {\n      return part.numeric && typeof output[part.idx] == 'undefined';\n    });\n\n    // if we have no unresolved parts, then return the value\n    if (unresolved.length === 0) {\n      return output.join('');\n    }\n\n    // otherwise, return the collect function again\n    return collect(\n      parts,\n      output,\n      indexShift + numericResolved.length\n    );\n  };\n}\n\nfunction applyModifiers(modifiers, value) {\n  // if we have modifiers, then tweak the output\n  for (var ii = 0, count = modifiers.length; ii < count; ii++) {\n    value = modifiers[ii](value);\n  }\n\n  return value;\n}\n\nfunction createModifiers(modifierStrings) {\n  var modifiers = [];\n  var parts;\n  var fn;\n  \n  for (var ii = 0, count = modifierStrings.length; ii < count; ii++) {\n    parts = modifierStrings[ii].split(':');\n    fn = mods[parts[0].toLowerCase()];\n    \n    if (fn) {\n      modifiers[modifiers.length] = fn.apply(null, parts.slice(1));\n    }\n  }\n  \n  return modifiers;\n}\n",
    "/* jshint node: true */\n'use strict';\n\n/**\n  ## Modifiers\n\n**/\n\n/**\n  ### Length Modifier (len)\n\n  The length modifier is used to ensure that a string is exactly the length specified.  The string is sliced to the required max length, and then padded out with spaces (or a specified character) to meet the required length.\n\n  ```js\n  // pad the string test to 10 characters\n  formatter('{{ 0|len:10 }}')('test');   // 'test      '\n\n  // pad the string test to 10 characters, using a as the padding character\n  formatter('{{ 0|len:10:a }}')('test'); // 'testaaaaaa'\n  ```\n**/\nexports.len = function(length, padder) {\n  var testInt = parseInt(padder, 10);\n  var isNumber;\n\n  // default the padder to a space\n  padder = (! isNaN(testInt)) ? testInt : (padder || ' ');\n\n  // check whether we have a number for padding (we will pad left if we do)\n  isNumber = typeof padder == 'number';\n  \n  return function(input) {\n    var output = input.toString().slice(0, length);\n    \n    // pad the string to the required length\n    while (output.length < length) {\n      output = isNumber ? padder + output : output + padder;\n    }\n    \n    return output;\n  };\n};",
    "/* jshint node: true */\n/* global document, location, Primus: false */\n'use strict';\n\nvar reTrailingSlash = /\\/$/;\nvar formatter = require('formatter');\nvar primusUrl = formatter('{{ signalhost }}{{ primusPath }}');\n\n/**\n  ### loadPrimus(signalhost, opts?, callback)\n\n  This is a convenience function that is patched into the signaller to assist\n  with loading the `primus.js` client library from an `rtc-switchboard`\n  signaling server.\n\n  In the case that you wish to load `primus.js` from a location other than\n  the default location of `{{ signalhost }}/rtc.io/primus.js` you can\n  provide an options object which allows for the following customizations:\n\n  - `primusPath` (default: `/rtc.io/primus.js`)\n\n    The path at which the `primus.js` file can be found on the signalhost.\n\n   __NOTE:__ The above options are passed through when creating a\n   signaller object, and thus packages such as\n   [rtc-quickconnect](https://github.com/rtc-io/rtc-quickconnect)\n   will allow you to make the customisation with it's top level\n   options also.\n\n**/\nmodule.exports = function(signalhost, opts, callback) {\n  var anchor = document.createElement('a');\n  var script;\n  var scriptSrc;\n\n  if (typeof opts == 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  // initialise the anchor with the signalhost\n  anchor.href = signalhost;\n\n  // initialise the script location\n  scriptSrc = primusUrl({\n    signalhost: signalhost.replace(reTrailingSlash, ''),\n    primusPath: (opts || {}).primusPath || '/rtc.io/primus.js'\n  });\n\n  // look for the script first\n  script = document.querySelector('script[src=\"' + scriptSrc + '\"]');\n\n  // if we found, the script trigger the callback immediately\n  if (script && typeof Primus != 'undefined') {\n    return callback(null, Primus);\n  }\n  // otherwise, if the script exists but Primus is not loaded,\n  // then wait for the load\n  else if (script) {\n    script.addEventListener('load', function() {\n      callback(null, Primus);\n    });\n\n    return;\n  }\n\n  // otherwise create the script and load primus\n  script = document.createElement('script');\n  script.src = scriptSrc;\n\n  script.onerror = callback;\n  script.addEventListener('load', function() {\n    // if we have a signalhost that is not basepathed at /\n    // then tweak the primus prototype\n    if (anchor.pathname !== '/') {\n      Primus.prototype.pathname = anchor.pathname.replace(reTrailingSlash, '') +\n        Primus.prototype.pathname;\n    }\n\n    callback(null, Primus);\n  });\n\n  document.body.appendChild(script);\n};\n",
    "/* jshint node: true */\n'use strict';\n\nvar debug = require('cog/logger')('rtc-signaller');\nvar jsonparse = require('cog/jsonparse');\n\n/**\n  ### signaller process handling\n\n  When a signaller's underling messenger emits a `data` event this is\n  delegated to a simple message parser, which applies the following simple\n  logic:\n\n  - Is the message a `/to` message. If so, see if the message is for this\n    signaller (checking the target id - 2nd arg).  If so pass the\n    remainder of the message onto the standard processing chain.  If not,\n    discard the message.\n\n  - Is the message a command message (prefixed with a forward slash). If so,\n    look for an appropriate message handler and pass the message payload on\n    to it.\n\n  - Finally, does the message match any patterns that we are listening for?\n    If so, then pass the entire message contents onto the registered handler.\n**/\nmodule.exports = function(signaller, opts) {\n  var handlers = require('./handlers')(signaller, opts);\n\n  function sendEvent(parts, srcState, data) {\n    // initialise the event name\n    var evtName = parts[0].slice(1);\n\n    // convert any valid json objects to json\n    var args = parts.slice(2).map(jsonparse);\n\n    signaller.apply(\n      signaller,\n      [evtName].concat(args).concat([srcState, data])\n    );\n  }\n\n  return function(originalData) {\n    var data = originalData;\n    var isMatch = true;\n    var parts;\n    var handler;\n    var srcData;\n    var srcState;\n    var isDirectMessage = false;\n\n    // discard primus messages\n    if (data && data.slice(0, 6) === 'primus') {\n      return;\n    }\n\n    // force the id into string format so we can run length and comparison tests on it\n    var id = signaller.id + '';\n    debug('signaller ' + id + ' received data: ' + originalData);\n\n    // process /to messages\n    if (data.slice(0, 3) === '/to') {\n      isMatch = data.slice(4, id.length + 4) === id;\n      if (isMatch) {\n        parts = data.slice(5 + id.length).split('|').map(jsonparse);\n\n        // get the source data\n        isDirectMessage = true;\n\n        // extract the vector clock and update the parts\n        parts = parts.map(jsonparse);\n      }\n    }\n\n    // if this is not a match, then bail\n    if (! isMatch) {\n      return;\n    }\n\n    // chop the data into parts\n    parts = parts || data.split('|').map(jsonparse);\n\n    // if we have a specific handler for the action, then invoke\n    if (typeof parts[0] == 'string') {\n      // extract the metadata from the input data\n      srcData = parts[1];\n\n      // if we got data from ourself, then this is pretty dumb\n      // but if we have then throw it away\n      if (srcData && srcData.id === signaller.id) {\n        return console.warn('got data from ourself, discarding');\n      }\n\n      // get the source state\n      srcState = signaller.peers.get(srcData && srcData.id) || srcData;\n\n      // handle commands\n      if (parts[0].charAt(0) === '/') {\n        // look for a handler for the message type\n        handler = handlers[parts[0].slice(1)];\n\n        if (typeof handler == 'function') {\n          handler(\n            parts.slice(2),\n            parts[0].slice(1),\n            srcData,\n            srcState,\n            isDirectMessage\n          );\n        }\n        else {\n          sendEvent(parts, srcState, originalData);\n        }\n      }\n      // otherwise, emit data\n      else {\n        signaller(\n          'data',\n          parts.slice(0, 1).concat(parts.slice(2)),\n          srcData,\n          srcState,\n          isDirectMessage\n        );\n      }\n    }\n  };\n};\n",
    "/* jshint node: true */\n'use strict';\n\nvar debug = require('cog/logger')('rtc-signaller');\nvar detect = require('rtc-core/detect');\nvar defaults = require('cog/defaults');\nvar extend = require('cog/extend');\nvar mbus = require('mbus');\nvar throttle = require('cog/throttle');\nvar getable = require('cog/getable');\nvar uuid = require('cuid');\n\n// initialise the list of valid \"write\" methods\nvar WRITE_METHODS = ['write', 'send'];\nvar CLOSE_METHODS = ['close', 'end'];\n\n// initialise signaller metadata so we don't have to include the package.json\n// TODO: make this checkable with some kind of prepublish script\nvar metadata = {\n  version: '3.1.0'\n};\n\n/**\n  # rtc-signaller\n\n  The `rtc-signaller` module provides a transportless signalling\n  mechanism for WebRTC.\n\n  ## Purpose\n\n  <<< docs/purpose.md\n\n  ## Getting Started\n\n  While the signaller is capable of communicating by a number of different\n  messengers (i.e. anything that can send and receive messages over a wire)\n  it comes with support for understanding how to connect to an\n  [rtc-switchboard](https://github.com/rtc-io/rtc-switchboard) out of the box.\n\n  The following code sample demonstrates how:\n\n  <<< examples/getting-started.js\n\n  <<< docs/events.md\n\n  <<< docs/signalflow-diagrams.md\n\n  ## Reference\n\n  The `rtc-signaller` module is designed to be used primarily in a functional\n  way and when called it creates a new signaller that will enable\n  you to communicate with other peers via your messaging network.\n\n  ```js\n  // create a signaller from something that knows how to send messages\n  var signaller = require('rtc-signaller')(messenger);\n  ```\n\n  As demonstrated in the getting started guide, you can also pass through\n  a string value instead of a messenger instance if you simply want to\n  connect to an existing `rtc-switchboard` instance.\n\n**/\nmodule.exports = function(messenger, opts) {\n  // get the autoreply setting\n  var autoreply = (opts || {}).autoreply;\n  var connect = (opts || {}).connect;\n\n  // initialise the metadata\n  var localMeta = {};\n\n  // create the signaller\n  var signaller = mbus('', (opts || {}).logger);\n\n  // initialise the id\n  var id = signaller.id = (opts || {}).id || uuid();\n\n  // initialise the attributes\n  var attributes = signaller.attributes = {\n    browser: detect.browser,\n    browserVersion: detect.browserVersion,\n    id: id,\n    agent: 'signaller@' + metadata.version\n  };\n\n  // create the peers map\n  var peers = signaller.peers = getable({});\n\n  // initialise the data event name\n\n  var connected = false;\n  var write;\n  var close;\n  var processor;\n  var announceTimer = 0;\n\n  function announceOnReconnect() {\n    signaller.announce();\n  }\n\n  function bindBrowserEvents() {\n    messenger.addEventListener('message', function(evt) {\n      processor(evt.data);\n    });\n\n    messenger.addEventListener('open', handleMessengerOpen);\n    messenger.addEventListener('close', handleMessengerClose);\n  }\n\n  function bindEvents() {\n    // handle message data events\n    messenger.on(opts.dataEvent, processor);\n    messenger.on(opts.openEvent, handleMessengerOpen);\n    messenger.on(opts.closeEvent, handleMessengerClose);\n    messenger.on(opts.errorEvent, handleMessengerClose);\n  }\n\n  function connectToHost(url) {\n    if (typeof connect != 'function') {\n      return signaller('error', new Error('no connect function'));\n    }\n\n    // load primus\n    connect(url, opts, function(err, socket) {\n      if (err) {\n        return signaller('error', err);\n      }\n\n      // create the actual messenger from a primus connection\n      signaller._messenger = messenger = socket.connect(url);\n\n      // now init\n      init();\n    });\n  }\n\n  function createDataLine(args) {\n    return args.map(prepareArg).join('|');\n  }\n\n  function createMetadata() {\n    return extend({}, localMeta, { id: signaller.id });\n  }\n\n  function extractProp(name) {\n    return messenger[name];\n  }\n\n  function handleMessengerClose(err) {\n    if (err instanceof Error) {\n      console.log('socket closed with error: ', err);\n    }\n\n    connected = false;\n    signaller('disconnected');\n  }\n\n  function handleMessengerOpen() {\n    connected = true;\n    signaller('open');\n    signaller('connected');\n  }\n\n  // attempt to detect whether the underlying messenger is closing\n  // this can be tough as we deal with both native (or simulated native)\n  // sockets or an abstraction layer such as primus\n  function isClosing() {\n    var isAbstraction = messenger &&\n        // a primus socket has a socket attribute\n        typeof messenger.socket != 'undefined';\n\n    return isAbstraction ? false : (\n      messenger &&\n      typeof messenger.readyState != 'undefined' &&\n      messenger.readyState >= 2\n    );\n  }\n\n  function isF(target) {\n    return typeof target == 'function';\n  }\n\n  function init() {\n    // extract the write and close function references\n    write = [opts.writeMethod].concat(WRITE_METHODS).map(extractProp).filter(isF)[0];\n    close = [opts.closeMethod].concat(CLOSE_METHODS).map(extractProp).filter(isF)[0];\n\n    // create the processor\n    signaller.process = processor = require('./processor')(signaller, opts);\n\n    // if the messenger doesn't provide a valid write method, then complain\n    if (typeof write != 'function') {\n      throw new Error('provided messenger does not implement a \"' +\n        opts.writeMethod + '\" write method');\n    }\n\n    // handle core browser messenging apis\n    if (typeof messenger.on == 'function') {\n      bindEvents();\n    }\n    else if (typeof messenger.addEventListener == 'function') {\n      bindBrowserEvents();\n    }\n\n    // determine if we are connected or not\n    connected = messenger.connected || false;\n    if (! connected) {\n      signaller.once('connected', function() {\n        // always announce on reconnect\n        signaller.on('connected', announceOnReconnect);\n      });\n    }\n\n    // emit the initialized event\n    setTimeout(signaller.bind(signaller, 'init'), 0);\n  }\n\n  function prepareArg(arg) {\n    if (typeof arg == 'object' && (! (arg instanceof String))) {\n      return JSON.stringify(arg);\n    }\n    else if (typeof arg == 'function') {\n      return null;\n    }\n\n    return arg;\n  }\n\n  /**\n    ### signaller#send(message, data*)\n\n    Use the send function to send a message to other peers in the current\n    signalling scope (if announced in a room this will be a room, otherwise\n    broadcast to all peers connected to the signalling server).\n\n  **/\n  var send = signaller.send = function() {\n    // iterate over the arguments and stringify as required\n    // var metadata = { id: signaller.id };\n    var args = [].slice.call(arguments);\n    var dataline;\n\n    // inject the metadata\n    args.splice(1, 0, createMetadata());\n    dataline = createDataLine(args);\n\n    // perform an isclosing check\n    if (isClosing()) {\n      return;\n    }\n\n    // if we are not initialized, then wait until we are\n    if (! connected) {\n      return signaller.once('connected', function() {\n        write.call(messenger, dataline);\n      });\n    }\n\n    // send the data over the messenger\n    return write.call(messenger, dataline);\n  };\n\n  /**\n    ### announce(data?)\n\n    The `announce` function of the signaller will pass an `/announce` message\n    through the messenger network.  When no additional data is supplied to\n    this function then only the id of the signaller is sent to all active\n    members of the messenging network.\n\n    #### Joining Rooms\n\n    To join a room using an announce call you simply provide the name of the\n    room you wish to join as part of the data block that you annouce, for\n    example:\n\n    ```js\n    signaller.announce({ room: 'testroom' });\n    ```\n\n    Signalling servers (such as\n    [rtc-switchboard](https://github.com/rtc-io/rtc-switchboard)) will then\n    place your peer connection into a room with other peers that have also\n    announced in this room.\n\n    Once you have joined a room, the server will only deliver messages that\n    you `send` to other peers within that room.\n\n    #### Providing Additional Announce Data\n\n    There may be instances where you wish to send additional data as part of\n    your announce message in your application.  For instance, maybe you want\n    to send an alias or nick as part of your announce message rather than just\n    use the signaller's generated id.\n\n    If for instance you were writing a simple chat application you could join\n    the `webrtc` room and tell everyone your name with the following announce\n    call:\n\n    ```js\n    signaller.announce({\n      room: 'webrtc',\n      nick: 'Damon'\n    });\n    ```\n\n    #### Announcing Updates\n\n    The signaller is written to distinguish between initial peer announcements\n    and peer data updates (see the docs on the announce handler below). As\n    such it is ok to provide any data updates using the announce method also.\n\n    For instance, I could send a status update as an announce message to flag\n    that I am going offline:\n\n    ```js\n    signaller.announce({ status: 'offline' });\n    ```\n\n  **/\n  signaller.announce = function(data, sender) {\n\n    function sendAnnounce() {\n      (sender || send)('/announce', attributes);\n      signaller('local:announce', attributes);\n    }\n\n    clearTimeout(announceTimer);\n\n    // update internal attributes\n    extend(attributes, data, { id: signaller.id });\n\n    // if we are already connected, then ensure we announce on\n    // reconnect\n    if (connected) {\n      // always announce on reconnect\n      signaller.removeListener('connected', announceOnReconnect);\n      signaller.on('connected', announceOnReconnect);\n    }\n\n    // send the attributes over the network\n    return announceTimer = setTimeout(function() {\n      if (! connected) {\n        return signaller.once('connected', sendAnnounce);\n      }\n\n      sendAnnounce();\n    }, (opts || {}).announceDelay || 10);\n  };\n\n  /**\n    ### isMaster(targetId)\n\n    A simple function that indicates whether the local signaller is the master\n    for it's relationship with peer signaller indicated by `targetId`.  Roles\n    are determined at the point at which signalling peers discover each other,\n    and are simply worked out by whichever peer has the lowest signaller id\n    when lexigraphically sorted.\n\n    For example, if we have two signaller peers that have discovered each\n    others with the following ids:\n\n    - `b11f4fd0-feb5-447c-80c8-c51d8c3cced2`\n    - `8a07f82e-49a5-4b9b-a02e-43d911382be6`\n\n    They would be assigned roles:\n\n    - `b11f4fd0-feb5-447c-80c8-c51d8c3cced2`\n    - `8a07f82e-49a5-4b9b-a02e-43d911382be6` (master)\n\n  **/\n  signaller.isMaster = function(targetId) {\n    var peer = peers.get(targetId);\n\n    return peer && peer.roleIdx !== 0;\n  };\n\n  /**\n    ### leave()\n\n    Tell the signalling server we are leaving.  Calling this function is\n    usually not required though as the signalling server should issue correct\n    `/leave` messages when it detects a disconnect event.\n\n  **/\n  signaller.leave = signaller.close = function() {\n    // send the leave signal\n    send('/leave', { id: id });\n\n    // stop announcing on reconnect\n    signaller.removeListener('connected', announceOnReconnect);\n\n    // call the close method\n    if (typeof close == 'function') {\n      close.call(messenger);\n    }\n  };\n\n  /**\n    ### metadata(data?)\n\n    Get (pass no data) or set the metadata that is passed through with each\n    request sent by the signaller.\n\n    __NOTE:__ Regardless of what is passed to this function, metadata\n    generated by the signaller will **always** include the id of the signaller\n    and this cannot be modified.\n  **/\n  signaller.metadata = function(data) {\n    if (arguments.length === 0) {\n      return extend({}, localMeta);\n    }\n\n    localMeta = extend({}, data);\n  };\n\n  /**\n    ### to(targetId)\n\n    Use the `to` function to send a message to the specified target peer.\n    A large parge of negotiating a WebRTC peer connection involves direct\n    communication between two parties which must be done by the signalling\n    server.  The `to` function provides a simple way to provide a logical\n    communication channel between the two parties:\n\n    ```js\n    var send = signaller.to('e95fa05b-9062-45c6-bfa2-5055bf6625f4').send;\n\n    // create an offer on a local peer connection\n    pc.createOffer(\n      function(desc) {\n        // set the local description using the offer sdp\n        // if this occurs successfully send this to our peer\n        pc.setLocalDescription(\n          desc,\n          function() {\n            send('/sdp', desc);\n          },\n          handleFail\n        );\n      },\n      handleFail\n    );\n    ```\n\n  **/\n  signaller.to = function(targetId) {\n    // create a sender that will prepend messages with /to|targetId|\n    var sender = function() {\n      // get the peer (yes when send is called to make sure it hasn't left)\n      var peer = signaller.peers.get(targetId);\n      var args;\n\n      if (! peer) {\n        throw new Error('Unknown peer: ' + targetId);\n      }\n\n      // if the peer is inactive, then abort\n      if (peer.inactive) {\n        return;\n      }\n\n      args = [\n        '/to',\n        targetId\n      ].concat([].slice.call(arguments));\n\n      // inject metadata\n      args.splice(3, 0, createMetadata());\n\n      setTimeout(function() {\n        var msg = createDataLine(args);\n        debug('TX (' + targetId + '): ' + msg);\n\n        write.call(messenger, msg);\n      }, 0);\n    };\n\n    return {\n      announce: function(data) {\n        return signaller.announce(data, sender);\n      },\n\n      send: sender,\n    }\n  };\n\n  // initialise opts defaults\n  opts = defaults({}, opts, require('./defaults'));\n\n  // set the autoreply flag\n  signaller.autoreply = autoreply === undefined || autoreply;\n\n  // if the messenger is a string, then we are going to attach to a\n  // ws endpoint and automatically set up primus\n  if (typeof messenger == 'string' || (messenger instanceof String)) {\n    connectToHost(messenger);\n  }\n  // otherwise, initialise the connection\n  else {\n    init();\n  }\n\n  // connect an instance of the messenger to the signaller\n  signaller._messenger = messenger;\n\n  // expose the process as a process function\n  signaller.process = processor;\n\n  return signaller;\n};\n",
    "/* jshint node: true */\n'use strict';\n\nvar debug = require('cog/logger')('rtc/cleanup');\n\nvar CANNOT_CLOSE_STATES = [\n  'closed'\n];\n\nvar EVENTS_DECOUPLE_BC = [\n  'addstream',\n  'datachannel',\n  'icecandidate',\n  'negotiationneeded',\n  'removestream',\n  'signalingstatechange'\n];\n\nvar EVENTS_DECOUPLE_AC = [\n  'iceconnectionstatechange'\n];\n\n/**\n  ### rtc-tools/cleanup\n\n  ```\n  cleanup(pc)\n  ```\n\n  The `cleanup` function is used to ensure that a peer connection is properly\n  closed and ready to be cleaned up by the browser.\n\n**/\nmodule.exports = function(pc) {\n  // see if we can close the connection\n  var currentState = pc.iceConnectionState;\n  var canClose = CANNOT_CLOSE_STATES.indexOf(currentState) < 0;\n\n  function decouple(events) {\n    events.forEach(function(evtName) {\n      if (pc['on' + evtName]) {\n        pc['on' + evtName] = null;\n      }\n    });\n  }\n\n  // decouple \"before close\" events\n  decouple(EVENTS_DECOUPLE_BC);\n\n  if (canClose) {\n    debug('attempting connection close, current state: '+ pc.iceConnectionState);\n    pc.close();\n  }\n\n  // remove the event listeners\n  // after a short delay giving the connection time to trigger\n  // close and iceconnectionstatechange events\n  setTimeout(function() {\n    decouple(EVENTS_DECOUPLE_AC);\n  }, 100);\n};\n",
    "/* jshint node: true */\n'use strict';\n\nvar mbus = require('mbus');\nvar queue = require('rtc-taskqueue');\nvar cleanup = require('./cleanup');\nvar monitor = require('./monitor');\nvar detect = require('./detect');\nvar findPlugin = require('rtc-core/plugin');\nvar throttle = require('cog/throttle');\nvar CLOSED_STATES = [ 'closed', 'failed' ];\n\n/**\n  ### rtc-tools/couple\n\n  #### couple(pc, targetId, signaller, opts?)\n\n  Couple a WebRTC connection with another webrtc connection identified by\n  `targetId` via the signaller.\n\n  The following options can be provided in the `opts` argument:\n\n  - `sdpfilter` (default: null)\n\n    A simple function for filtering SDP as part of the peer\n    connection handshake (see the Using Filters details below).\n\n  ##### Example Usage\n\n  ```js\n  var couple = require('rtc/couple');\n\n  couple(pc, '54879965-ce43-426e-a8ef-09ac1e39a16d', signaller);\n  ```\n\n  ##### Using Filters\n\n  In certain instances you may wish to modify the raw SDP that is provided\n  by the `createOffer` and `createAnswer` calls.  This can be done by passing\n  a `sdpfilter` function (or array) in the options.  For example:\n\n  ```js\n  // run the sdp from through a local tweakSdp function.\n  couple(pc, '54879965-ce43-426e-a8ef-09ac1e39a16d', signaller, {\n    sdpfilter: tweakSdp\n  });\n  ```\n\n**/\nfunction couple(pc, targetId, signaller, opts) {\n  var debugLabel = (opts || {}).debugLabel || 'rtc';\n  var debug = require('cog/logger')(debugLabel + '/couple');\n\n  // create a monitor for the connection\n  var mon = monitor(pc, targetId, signaller, (opts || {}).logger);\n  var emit = mbus('', mon);\n  var queuedCandidates = [];\n  var sdpFilter = (opts || {}).sdpfilter;\n  var reactive = (opts || {}).reactive;\n  var offerTimeout;\n  var endOfCandidates = true;\n  var plugin = findPlugin((opts || {}).plugins);\n\n  // configure the time to wait between receiving a 'disconnect'\n  // iceConnectionState and determining that we are closed\n  var disconnectTimeout = (opts || {}).disconnectTimeout || 10000;\n  var disconnectTimer;\n\n  // initilaise the negotiation helpers\n  var isMaster = signaller.isMaster(targetId);\n\n  // initialise the processing queue (one at a time please)\n  var q = queue(pc, opts);\n\n  var createOrRequestOffer = throttle(function() {\n    if (! isMaster) {\n      return signaller.to(targetId).send('/negotiate');\n    }\n\n    q.createOffer();\n  }, 100, { leading: false });\n\n  var debounceOffer = throttle(q.createOffer, 100, { leading: false });\n\n  function decouple() {\n    debug('decoupling ' + signaller.id + ' from ' + targetId);\n\n    // stop the monitor\n//     mon.removeAllListeners();\n    mon.stop();\n\n    // cleanup the peerconnection\n    cleanup(pc);\n\n    // remove listeners\n    signaller.removeListener('sdp', handleSdp);\n    signaller.removeListener('candidate', handleCandidate);\n    signaller.removeListener('negotiate', handleNegotiateRequest);\n  }\n\n  function handleCandidate(data) {\n    q.addIceCandidate(data);\n  }\n\n  function handleSdp(sdp, src) {\n    emit('sdp.remote', sdp);\n\n    // if the source is unknown or not a match, then don't process\n    if ((! src) || (src.id !== targetId)) {\n      return;\n    }\n\n    q.setRemoteDescription(sdp);\n  }\n\n  function handleConnectionClose() {\n    debug('captured pc close, iceConnectionState = ' + pc.iceConnectionState);\n    decouple();\n  }\n\n  function handleDisconnect() {\n    debug('captured pc disconnect, monitoring connection status');\n\n    // start the disconnect timer\n    disconnectTimer = setTimeout(function() {\n      debug('manually closing connection after disconnect timeout');\n      pc.close();\n    }, disconnectTimeout);\n\n    mon.on('statechange', handleDisconnectAbort);\n  }\n\n  function handleDisconnectAbort() {\n    debug('connection state changed to: ' + pc.iceConnectionState);\n    resetDisconnectTimer();\n\n    // if we have a closed or failed status, then close the connection\n    if (CLOSED_STATES.indexOf(pc.iceConnectionState) >= 0) {\n      return mon('closed');\n    }\n\n    mon.once('disconnect', handleDisconnect);\n  };\n\n  function handleLocalCandidate(evt) {\n    if (evt.candidate) {\n      resetDisconnectTimer();\n\n      emit('ice.local', evt.candidate);\n      signaller.to(targetId).send('/candidate', evt.candidate);\n      endOfCandidates = false;\n    }\n    else if (! endOfCandidates) {\n      endOfCandidates = true;\n      emit('ice.gathercomplete');\n      signaller.to(targetId).send('/endofcandidates', {});\n    }\n  }\n\n  function handleNegotiateRequest(src) {\n    if (src.id === targetId) {\n      emit('negotiate.request', src.id);\n      debounceOffer();\n    }\n  }\n\n  function resetDisconnectTimer() {\n    mon.off('statechange', handleDisconnectAbort);\n\n    // clear the disconnect timer\n    debug('reset disconnect timer, state: ' + pc.iceConnectionState);\n    clearTimeout(disconnectTimer);\n  }\n\n  // when regotiation is needed look for the peer\n  if (reactive) {\n    pc.onnegotiationneeded = function() {\n      emit('negotiate.renegotiate');\n      createOrRequestOffer();\n    };\n  }\n\n  pc.onicecandidate = handleLocalCandidate;\n\n  // when the task queue tells us we have sdp available, send that over the wire\n  q.on('sdp.local', function(desc) {\n    signaller.to(targetId).send('/sdp', desc);\n  });\n\n  // when we receive sdp, then\n  signaller.on('sdp', handleSdp);\n  signaller.on('candidate', handleCandidate);\n\n  // if this is a master connection, listen for negotiate events\n  if (isMaster) {\n    signaller.on('negotiate', handleNegotiateRequest);\n  }\n\n  // when the connection closes, remove event handlers\n  mon.once('closed', handleConnectionClose);\n  mon.once('disconnected', handleDisconnect);\n\n  // patch in the create offer functions\n  mon.createOffer = createOrRequestOffer;\n\n  return mon;\n}\n\nmodule.exports = couple;\n",
    "/* jshint node: true */\n'use strict';\n\n/**\n  ### rtc-tools/detect\n\n  Provide the [rtc-core/detect](https://github.com/rtc-io/rtc-core#detect)\n  functionality.\n**/\nmodule.exports = require('rtc-core/detect');\n",
    "/* jshint node: true */\n'use strict';\n\nvar debug = require('cog/logger')('generators');\nvar detect = require('./detect');\nvar defaults = require('cog/defaults');\n\nvar mappings = {\n  create: {\n    dtls: function(c) {\n      if (! detect.moz) {\n        c.optional = (c.optional || []).concat({ DtlsSrtpKeyAgreement: true });\n      }\n    }\n  }\n};\n\n/**\n  ### rtc-tools/generators\n\n  The generators package provides some utility methods for generating\n  constraint objects and similar constructs.\n\n  ```js\n  var generators = require('rtc/generators');\n  ```\n\n**/\n\n/**\n  #### generators.config(config)\n\n  Generate a configuration object suitable for passing into an W3C\n  RTCPeerConnection constructor first argument, based on our custom config.\n\n  In the event that you use short term authentication for TURN, and you want\n  to generate new `iceServers` regularly, you can specify an iceServerGenerator\n  that will be used prior to coupling. This generator should return a fully\n  compliant W3C (RTCIceServer dictionary)[http://www.w3.org/TR/webrtc/#idl-def-RTCIceServer].\n\n  If you pass in both a generator and iceServers, the iceServers _will be\n  ignored and the generator used instead.\n**/\n\nvar iceServerGenerator = function () {\n  return [];\n}\n\nexports.config = function(config) {\n  var iceServerGenerator = (config || {}).iceServerGenerator;\n\n  return defaults({}, config, {\n    iceServers: typeof iceServerGenerator == 'function' ? iceServerGenerator() : []\n  });\n};\n\n/**\n  #### generators.connectionConstraints(flags, constraints)\n\n  This is a helper function that will generate appropriate connection\n  constraints for a new `RTCPeerConnection` object which is constructed\n  in the following way:\n\n  ```js\n  var conn = new RTCPeerConnection(flags, constraints);\n  ```\n\n  In most cases the constraints object can be left empty, but when creating\n  data channels some additional options are required.  This function\n  can generate those additional options and intelligently combine any\n  user defined constraints (in `constraints`) with shorthand flags that\n  might be passed while using the `rtc.createConnection` helper.\n**/\nexports.connectionConstraints = function(flags, constraints) {\n  var generated = {};\n  var m = mappings.create;\n  var out;\n\n  // iterate through the flags and apply the create mappings\n  Object.keys(flags || {}).forEach(function(key) {\n    if (m[key]) {\n      m[key](generated);\n    }\n  });\n\n  // generate the connection constraints\n  out = defaults({}, constraints, generated);\n  debug('generated connection constraints: ', out);\n\n  return out;\n};\n",
    "/* jshint node: true */\n\n'use strict';\n\n/**\n  # rtc-tools\n\n  The `rtc-tools` module does most of the heavy lifting within the\n  [rtc.io](http://rtc.io) suite.  Primarily it handles the logic of coupling\n  a local `RTCPeerConnection` with it's remote counterpart via an\n  [rtc-signaller](https://github.com/rtc-io/rtc-signaller) signalling\n  channel.\n\n  ## Getting Started\n\n  If you decide that the `rtc-tools` module is a better fit for you than either\n  [rtc-quickconnect](https://github.com/rtc-io/rtc-quickconnect) or\n  [rtc-glue](https://github.com/rtc-io/rtc-glue) then the code snippet below\n  will provide you a guide on how to get started using it in conjunction with\n  the [rtc-signaller](https://github.com/rtc-io/rtc-signaller) and\n  [rtc-media](https://github.com/rtc-io/rtc-media) modules:\n\n  <<< examples/getting-started.js\n\n  This code definitely doesn't cover all the cases that you need to consider\n  (i.e. peers leaving, etc) but it should demonstrate how to:\n\n  1. Capture video and add it to a peer connection\n  2. Couple a local peer connection with a remote peer connection\n  3. Deal with the remote steam being discovered and how to render\n     that to the local interface.\n\n  ## Reference\n\n**/\n\nvar gen = require('./generators');\n\n// export detect\nvar detect = exports.detect = require('./detect');\nvar findPlugin = require('rtc-core/plugin');\n\n// export cog logger for convenience\nexports.logger = require('cog/logger');\n\n// export peer connection\nvar RTCPeerConnection =\nexports.RTCPeerConnection = detect('RTCPeerConnection');\n\n// add the couple utility\nexports.couple = require('./couple');\n\n/**\n  ### createConnection\n\n  ```\n  createConnection(opts?, constraints?) => RTCPeerConnection\n  ```\n\n  Create a new `RTCPeerConnection` auto generating default opts as required.\n\n  ```js\n  var conn;\n\n  // this is ok\n  conn = rtc.createConnection();\n\n  // and so is this\n  conn = rtc.createConnection({\n    iceServers: []\n  });\n  ```\n**/\nexports.createConnection = function(opts, constraints) {\n  var plugin = findPlugin((opts || {}).plugins);\n\n  // generate the config based on options provided\n  var config = gen.config(opts);\n\n  // generate appropriate connection constraints\n  var constraints = gen.connectionConstraints(opts, constraints);\n\n  if (plugin && typeof plugin.createConnection == 'function') {\n    return plugin.createConnection(config, constraints);\n  }\n  else {\n    return new ((opts || {}).RTCPeerConnection || RTCPeerConnection)(\n      config, constraints\n    );\n  }\n};\n",
    "/* jshint node: true */\n'use strict';\n\nvar mbus = require('mbus');\n\n// define some state mappings to simplify the events we generate\nvar stateMappings = {\n  completed: 'connected'\n};\n\n// define the events that we need to watch for peer connection\n// state changes\nvar peerStateEvents = [\n  'signalingstatechange',\n  'iceconnectionstatechange',\n];\n\n/**\n  ### rtc-tools/monitor\n\n  ```\n  monitor(pc, targetId, signaller, parentBus) => mbus\n  ```\n\n  The monitor is a useful tool for determining the state of `pc` (an\n  `RTCPeerConnection`) instance in the context of your application. The\n  monitor uses both the `iceConnectionState` information of the peer\n  connection and also the various\n  [signaller events](https://github.com/rtc-io/rtc-signaller#signaller-events)\n  to determine when the connection has been `connected` and when it has\n  been `disconnected`.\n\n  A monitor created `mbus` is returned as the result of a\n  [couple](https://github.com/rtc-io/rtc#rtccouple) between a local peer\n  connection and it's remote counterpart.\n\n**/\nmodule.exports = function(pc, targetId, signaller, parentBus) {\n  var monitor = mbus('', parentBus);\n  var state;\n\n  function checkState() {\n    var newState = getMappedState(pc.iceConnectionState);\n\n    // flag the we had a state change\n    monitor('statechange', pc, newState);\n\n    // if the active state has changed, then send the appopriate message\n    if (state !== newState) {\n      monitor(newState);\n      state = newState;\n    }\n  }\n\n  function handleClose() {\n    monitor('closed');\n  }\n\n  function handlePeerLeave(peerId) {\n    // if the peer leaving is not the peer we are connected to\n    // then we aren't interested\n    if (peerId !== targetId) {\n      return;\n    }\n\n    // trigger a closed event\n    monitor('closed');\n  }\n\n  pc.addEventListener('close', handleClose);\n  peerStateEvents.forEach(function(evtName) {\n    pc.addEventListener(evtName, checkState);\n  });\n\n  monitor.stop = function() {\n    pc.removeEventListener('close', handleClose);\n    peerStateEvents.forEach(function(evtName) {\n      pc.removeEventListener(evtName, checkState);\n    });\n\n    // remove the peer:leave listener\n    if (signaller && typeof signaller.removeListener == 'function') {\n      signaller.removeListener('peer:leave', handlePeerLeave);\n    }\n  };\n\n  monitor.checkState = checkState;\n\n  // if we haven't been provided a valid peer connection, abort\n  if (! pc) {\n    return monitor;\n  }\n\n  // determine the initial is active state\n  state = getMappedState(pc.iceConnectionState);\n\n  // if we've been provided a signaller, then watch for peer:leave events\n  if (signaller && typeof signaller.on == 'function') {\n    signaller.on('peer:leave', handlePeerLeave);\n  }\n\n  return monitor;\n};\n\n/* internal helpers */\n\nfunction getMappedState(state) {\n  return stateMappings[state] || state;\n}\n",
    "var detect = require('rtc-core/detect');\nvar findPlugin = require('rtc-core/plugin');\nvar PriorityQueue = require('priorityqueuejs');\n\n// some validation routines\nvar checkCandidate = require('rtc-validator/candidate');\n\n// the sdp cleaner\nvar sdpclean = require('rtc-sdpclean');\n\nvar PRIORITY_LOW = 100;\nvar PRIORITY_WAIT = 1000;\n\n// priority order (lower is better)\nvar DEFAULT_PRIORITIES = [\n  'candidate',\n  'setLocalDescription',\n  'setRemoteDescription',\n  'createAnswer',\n  'createOffer'\n];\n\n// define event mappings\nvar METHOD_EVENTS = {\n  setLocalDescription: 'setlocaldesc',\n  setRemoteDescription: 'setremotedesc',\n  createOffer: 'offer',\n  createAnswer: 'answer'\n};\n\n/**\n  # rtc-taskqueue\n\n  This is a package that assists with applying actions to an `RTCPeerConnection`\n  in as reliable order as possible. It is primarily used by the coupling logic\n  of the [`rtc-tools`](https://github.com/rtc-io/rtc-tools).\n\n  ## Example Usage\n\n  To be completed\n**/\nmodule.exports = function(pc, opts) {\n  // create the task queue\n  var queue = new PriorityQueue(orderTasks);\n  var tq = require('mbus')('', (opts || {}).logger);\n\n  // initialise task importance\n  var priorities = (opts || {}).priorities || DEFAULT_PRIORITIES;\n\n  // check for plugin usage\n  var plugin = findPlugin((opts || {}).plugins);\n\n  // initialise state tracking\n  var checkQueueTimer = 0;\n  var currentTask;\n  var defaultFail = tq.bind(tq, 'fail');\n\n  // initialise session description and icecandidate objects\n  var RTCSessionDescription = (opts || {}).RTCSessionDescription ||\n    detect('RTCSessionDescription');\n\n  var RTCIceCandidate = (opts || {}).RTCIceCandidate ||\n    detect('RTCIceCandidate');\n\n  function abortQueue(err) {\n    console.error(err);\n  }\n\n  function applyCandidate(task, next) {\n    var candidate;\n    var data = task.args[0];\n\n    // we have a null candidate, we have finished gathering candidates\n    if (! data.candidate) {\n      return next();\n    }\n\n    try {\n      candidate = createIceCandidate(data);\n      pc.addIceCandidate(candidate);\n      tq('ice.remote.applied', candidate);\n    }\n    catch (e) {\n      tq('ice.remote.invalid', candidate);\n      return next(e);\n    }\n\n    next();\n  }\n\n  function checkQueue() {\n    // peek at the next item on the queue\n    var next = (! queue.isEmpty()) && (! currentTask) && queue.peek();\n    var ready = next && testReady(next);\n    var retry = (! queue.isEmpty()) && isNotClosed(pc);\n\n    // reset the queue timer\n    checkQueueTimer = 0;\n\n    // if we don't have a task ready, then abort\n    if (! ready) {\n      return retry && triggerQueueCheck();\n    }\n\n    // update the current task (dequeue)\n    currentTask = queue.deq();\n\n    // process the task\n    currentTask.fn(currentTask, function(err) {\n      var fail = currentTask.fail || defaultFail;\n      var pass = currentTask.pass;\n      var taskName = currentTask.name;\n\n      // unset the current task\n      currentTask = null;\n\n      // if errored, fail\n      if (err) {\n        console.error(taskName + ' task failed: ', err);\n        return fail(err);\n      }\n\n      if (typeof pass == 'function') {\n        pass.apply(null, [].slice.call(arguments, 1));\n      }\n\n      triggerQueueCheck();\n    });\n  }\n\n  function cleansdp(desc) {\n    // ensure we have clean sdp\n    var sdpErrors = [];\n    var sdp = desc && sdpclean(desc.sdp, { collector: sdpErrors });\n\n    // if we don't have a match, log some info\n    if (desc && sdp !== desc.sdp) {\n      console.info('invalid lines removed from sdp: ', sdpErrors);\n      desc.sdp = sdp;\n    }\n\n    return desc;\n  }\n\n  function completeConnection() {\n    if (pc.signalingState === 'have-remote-offer') {\n      return tq.createAnswer();\n    }\n  }\n\n  function createIceCandidate(data) {\n    if (plugin && typeof plugin.createIceCandidate == 'function') {\n      return plugin.createIceCandidate(data);\n    }\n\n    return new RTCIceCandidate(data);\n  }\n\n  function createSessionDescription(data) {\n    if (plugin && typeof plugin.createSessionDescription == 'function') {\n      return plugin.createSessionDescription(data);\n    }\n\n    return new RTCSessionDescription(data);\n  }\n\n  function emitSdp(sdp) {\n    tq('sdp.local', pc.localDescription);\n  }\n\n  function enqueue(name, handler, opts) {\n    return function() {\n      var args = [].slice.call(arguments);\n\n      if (opts && typeof opts.processArgs == 'function') {\n        args = args.map(opts.processArgs);\n      }\n\n      queue.enq({\n        args: args,\n        name: name,\n        fn: handler,\n\n        // initilaise any checks that need to be done prior\n        // to the task executing\n        checks: [ isNotClosed ].concat((opts || {}).checks || []),\n\n        // initialise the pass and fail handlers\n        pass: (opts || {}).pass,\n        fail: (opts || {}).fail\n      });\n\n      triggerQueueCheck();\n    };\n  }\n\n  function execMethod(task, next) {\n    var fn = pc[task.name];\n    var eventName = METHOD_EVENTS[task.name] || (task.name || '').toLowerCase();\n    var cbArgs = [ success, fail ];\n    var isOffer = task.name === 'createOffer';\n\n    function fail(err) {\n      tq.apply(tq, [ 'negotiate.error', task.name, err ].concat(task.args));\n      next(err);\n    }\n\n    function success() {\n      tq.apply(tq, [ ['negotiate', eventName, 'ok'], task.name ].concat(task.args));\n      next.apply(null, [null].concat([].slice.call(arguments)));\n    }\n\n    if (typeof fn != 'function') {\n      return next(new Error('cannot call \"' + task.name + '\" on RTCPeerConnection'));\n    }\n\n    // invoke the function\n    tq.apply(tq, ['negotiate.' + eventName].concat(task.args));\n    fn.apply(\n      pc,\n      task.args.concat(cbArgs).concat(isOffer ? generateConstraints() : [])\n    );\n  }\n\n  function extractCandidateEventData(data) {\n    // if we have been passed an event, then extract the candidate from the data\n    if (data.srcElement && data.candidate) {\n      data = data.candidate;\n    }\n\n    return data;\n  }\n\n  function generateConstraints() {\n    var allowedKeys = {\n      offertoreceivevideo: 'OfferToReceiveVideo',\n      offertoreceiveaudio: 'OfferToReceiveAudio',\n      icerestart: 'IceRestart',\n      voiceactivitydetection: 'VoiceActivityDetection'\n    };\n\n    var constraints = {\n      OfferToReceiveVideo: true,\n      OfferToReceiveAudio: true\n    };\n\n    // update known keys to match\n    Object.keys(opts || {}).forEach(function(key) {\n      if (allowedKeys[key.toLowerCase]) {\n        constraints[allowedKeys[key.toLowerCase()]] = opts[key];\n      }\n    });\n\n    return { mandatory: constraints };\n  }\n\n  function hasLocalOrRemoteDesc(pc, task) {\n    return pc.__hasDesc || (pc.__hasDesc = !!pc.remoteDescription);\n  }\n\n  function isNotNegotiating(pc) {\n    return pc.signalingState !== 'have-local-offer';\n  }\n\n  function isNotClosed(pc) {\n    return pc.signalingState !== 'closed';\n  }\n\n  function isStable(pc) {\n    return pc.signalingState === 'stable';\n  }\n\n  function isValidCandidate(pc, data) {\n    return data.__valid ||\n      (data.__valid = checkCandidate(data.args[0]).length === 0);\n  }\n\n  function orderTasks(a, b) {\n    // apply each of the checks for each task\n    var tasks = [a,b];\n    var readiness = tasks.map(testReady);\n    var taskPriorities = tasks.map(function(task, idx) {\n      var ready = readiness[idx];\n      var priority = ready && priorities.indexOf(task.name);\n\n      return ready ? (priority >= 0 ? priority : PRIORITY_LOW) : PRIORITY_WAIT;\n    });\n\n    return taskPriorities[1] - taskPriorities[0];\n  }\n\n  // check whether a task is ready (does it pass all the checks)\n  function testReady(task) {\n    return (task.checks || []).reduce(function(memo, check) {\n      return memo && check(pc, task);\n    }, true);\n  }\n\n  function triggerQueueCheck() {\n    if (checkQueueTimer) return;\n    checkQueueTimer = setTimeout(checkQueue, 50);\n  }\n\n  // patch in the queue helper methods\n  tq.addIceCandidate = enqueue('addIceCandidate', applyCandidate, {\n    processArgs: extractCandidateEventData,\n    checks: [ hasLocalOrRemoteDesc, isValidCandidate ]\n  });\n\n  tq.setLocalDescription = enqueue('setLocalDescription', execMethod, {\n    processArgs: cleansdp,\n    pass: emitSdp\n  });\n\n  tq.setRemoteDescription = enqueue('setRemoteDescription', execMethod, {\n    processArgs: createSessionDescription,\n    pass: completeConnection\n  });\n\n  tq.createOffer = enqueue('createOffer', execMethod, {\n    checks: [ isNotNegotiating ],\n    pass: tq.setLocalDescription\n  });\n\n  tq.createAnswer = enqueue('createAnswer', execMethod, {\n    pass: tq.setLocalDescription\n  });\n\n  return tq;\n};\n",
    "/**\n * Expose `PriorityQueue`.\n */\nmodule.exports = PriorityQueue;\n\n/**\n * Initializes a new empty `PriorityQueue` with the given `comparator(a, b)`\n * function, uses `.DEFAULT_COMPARATOR()` when no function is provided.\n *\n * The comparator function must return a positive number when `a > b`, 0 when\n * `a == b` and a negative number when `a < b`.\n *\n * @param {Function}\n * @return {PriorityQueue}\n * @api public\n */\nfunction PriorityQueue(comparator) {\n  this._comparator = comparator || PriorityQueue.DEFAULT_COMPARATOR;\n  this._elements = [];\n}\n\n/**\n * Compares `a` and `b`, when `a > b` it returns a positive number, when\n * it returns 0 and when `a < b` it returns a negative number.\n *\n * @param {String|Number} a\n * @param {String|Number} b\n * @return {Number}\n * @api public\n */\nPriorityQueue.DEFAULT_COMPARATOR = function(a, b) {\n  if (a instanceof Number && b instanceof Number) {\n    return a - b;\n  } else {\n    a = a.toString();\n    b = b.toString();\n\n    if (a == b) return 0;\n\n    return (a > b) ? 1 : -1;\n  }\n};\n\n/**\n * Returns whether the priority queue is empty or not.\n *\n * @return {Boolean}\n * @api public\n */\nPriorityQueue.prototype.isEmpty = function() {\n  return this.size() === 0;\n};\n\n/**\n * Peeks at the top element of the priority queue.\n *\n * @return {Object}\n * @throws {Error} when the queue is empty.\n * @api public\n */\nPriorityQueue.prototype.peek = function() {\n  if (this.isEmpty()) throw new Error('PriorityQueue is empty');\n\n  return this._elements[0];\n};\n\n/**\n * Dequeues the top element of the priority queue.\n *\n * @return {Object}\n * @throws {Error} when the queue is empty.\n * @api public\n */\nPriorityQueue.prototype.deq = function() {\n  var first = this.peek();\n  var last = this._elements.pop();\n  var size = this.size();\n\n  if (size === 0) return first;\n\n  this._elements[0] = last;\n  var current = 0;\n\n  while (current < size) {\n    var largest = current;\n    var left = (2 * current) + 1;\n    var right = (2 * current) + 2;\n\n    if (left < size && this._compare(left, largest) > 0) {\n      largest = left;\n    }\n\n    if (right < size && this._compare(right, largest) > 0) {\n      largest = right;\n    }\n\n    if (largest === current) break;\n\n    this._swap(largest, current);\n    current = largest;\n  }\n\n  return first;\n};\n\n/**\n * Enqueues the `element` at the priority queue and returns its new size.\n *\n * @param {Object} element\n * @return {Number}\n * @api public\n */\nPriorityQueue.prototype.enq = function(element) {\n  var size = this._elements.push(element);\n  var current = size - 1;\n\n  while (current > 0) {\n    var parent = Math.floor((current - 1) / 2);\n\n    if (this._compare(current, parent) < 0) break;\n\n    this._swap(parent, current);\n    current = parent;\n  }\n\n  return size;\n};\n\n/**\n * Returns the size of the priority queue.\n *\n * @return {Number}\n * @api public\n */\nPriorityQueue.prototype.size = function() {\n  return this._elements.length;\n};\n\n/**\n *  Iterates over queue elements\n *\n *  @param {Function} fn\n */\nPriorityQueue.prototype.forEach = function(fn) {\n  return this._elements.forEach(fn);\n};\n\n/**\n * Compares the values at position `a` and `b` in the priority queue using its\n * comparator function.\n *\n * @param {Number} a\n * @param {Number} b\n * @return {Number}\n * @api private\n */\nPriorityQueue.prototype._compare = function(a, b) {\n  return this._comparator(this._elements[a], this._elements[b]);\n};\n\n/**\n * Swaps the values at position `a` and `b` in the priority queue.\n *\n * @param {Number} a\n * @param {Number} b\n * @api private\n */\nPriorityQueue.prototype._swap = function(a, b) {\n  var aux = this._elements[a];\n  this._elements[a] = this._elements[b];\n  this._elements[b] = aux;\n};\n",
    "var validators = [\n  [ /^(a\\=candidate.*)$/, require('rtc-validator/candidate') ]\n];\n\nvar reSdpLineBreak = /(\\r?\\n|\\\\r\\\\n)/;\n\n/**\n  # rtc-sdpclean\n\n  Remove invalid lines from your SDP.\n\n  ## Why?\n\n  This module removes the occasional \"bad egg\" that will slip into SDP when it\n  is generated by the browser.  In particular these situations are catered for:\n\n  - invalid ICE candidates\n\n**/\nmodule.exports = function(input, opts) {\n  var lineBreak = detectLineBreak(input);\n  var lines = input.split(lineBreak);\n  var collector = (opts || {}).collector;\n\n  // filter out invalid lines\n  lines = lines.filter(function(line) {\n    // iterate through the validators and use the one that matches\n    var validator = validators.reduce(function(memo, data, idx) {\n      return typeof memo != 'undefined' ? memo : (data[0].exec(line) && {\n        line: line.replace(data[0], '$1'),\n        fn: data[1]\n      });\n    }, undefined);\n\n    // if we have a validator, ensure we have no errors\n    var errors = validator ? validator.fn(validator.line) : [];\n\n    // if we have errors and an error collector, then add to the collector\n    if (collector) {\n      errors.forEach(function(err) {\n        collector.push(err);\n      });\n    }\n\n    return errors.length === 0;\n  });\n\n  return lines.join(lineBreak);\n};\n\nfunction detectLineBreak(input) {\n  var match = reSdpLineBreak.exec(input);\n\n  return match && match[0];\n}\n",
    "var debug = require('cog/logger')('rtc-validator');\nvar rePrefix = /^(?:a=)?candidate:/;\nvar reIP = /^(\\d+\\.){3}\\d+$/;\n\n/*\n\nvalidation rules as per:\nhttp://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-sdp-03#section-8.1\n\n   candidate-attribute   = \"candidate\" \":\" foundation SP component-id SP\n                           transport SP\n                           priority SP\n                           connection-address SP     ;from RFC 4566\n                           port         ;port from RFC 4566\n                           SP cand-type\n                           [SP rel-addr]\n                           [SP rel-port]\n                           *(SP extension-att-name SP\n                                extension-att-value)\n\n   foundation            = 1*32ice-char\n   component-id          = 1*5DIGIT\n   transport             = \"UDP\" / transport-extension\n   transport-extension   = token              ; from RFC 3261\n   priority              = 1*10DIGIT\n   cand-type             = \"typ\" SP candidate-types\n   candidate-types       = \"host\" / \"srflx\" / \"prflx\" / \"relay\" / token\n   rel-addr              = \"raddr\" SP connection-address\n   rel-port              = \"rport\" SP port\n   extension-att-name    = token\n   extension-att-value   = *VCHAR\n   ice-char              = ALPHA / DIGIT / \"+\" / \"/\"\n*/\nvar partValidation = [\n  [ /.+/, 'invalid foundation component', 'foundation' ],\n  [ /\\d+/, 'invalid component id', 'component-id' ],\n  [ /(UDP|TCP)/i, 'transport must be TCP or UDP', 'transport' ],\n  [ /\\d+/, 'numeric priority expected', 'priority' ],\n  [ reIP, 'invalid connection address', 'connection-address' ],\n  [ /\\d+/, 'invalid connection port', 'connection-port' ],\n  [ /typ/, 'Expected \"typ\" identifier', 'type classifier' ],\n  [ /.+/, 'Invalid candidate type specified', 'candidate-type' ]\n];\n\n/**\n  ### `rtc-validator/candidate`\n\n  Validate that an `RTCIceCandidate` (or plain old object with data, sdpMid,\n  etc attributes) is a valid ice candidate.\n\n  Specs reviewed as part of the validation implementation:\n\n  - <http://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-sdp-03#section-8.1>\n  - <http://tools.ietf.org/html/rfc5245>\n\n**/\nmodule.exports = function(data) {\n  var errors = [];\n  var candidate = data && (data.candidate || data);\n  var prefixMatch = candidate && rePrefix.exec(candidate);\n  var parts = prefixMatch && candidate.slice(prefixMatch[0].length).split(/\\s/);\n\n  if (! candidate) {\n    return [ new Error('empty candidate') ];\n  }\n\n  // check that the prefix matches expected\n  if (! prefixMatch) {\n    return [ new Error('candidate did not match expected sdp line format') ];\n  }\n\n  // perform the part validation\n  errors = errors.concat(parts.map(validateParts)).filter(Boolean);\n\n  return errors;\n};\n\nfunction validateParts(part, idx) {\n  var validator = partValidation[idx];\n\n  if (validator && (! validator[0].test(part))) {\n    debug(validator[2] + ' part failed validation: ' + part);\n    return new Error(validator[1]);\n  }\n}\n",
    "/**\n  ## chain\n\n  Create a function that will create the combined result of calling all\n  the provided functions in the provided order.\n\n  <<< examples/chain.js\n\n**/\nmodule.exports = function(fns) {\n  fns = [].concat(fns || []).concat([].slice.call(arguments, 1));\n\n  return function(value) {\n    return fns.reduce(function(memo, fn) {\n      var result = fn(memo);\n\n      return result !== undefined ? result : memo;\n    }, value || 0);\n  }\n};\n"
  ]
}